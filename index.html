<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON MEMORIES ‚Ä¢ Retro Photo Editor</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=VT323&family=Press+Start+2P&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --neon-pink: #ff2a6d;
            --neon-blue: #05d9e8;
            --neon-purple: #d300c5;
            --neon-yellow: #ffe66d;
            --neon-green: #39ff14;
            --dark-bg: #0a0118;
            --dark-surface: #150a28;
            --dark-card: #1a0d30;
            --accent-gradient: linear-gradient(135deg, #ff2a6d, #d300c5, #05d9e8);
        }

        * {
            scrollbar-width: thin;
            scrollbar-color: var(--neon-pink) var(--dark-surface);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        *::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        *::-webkit-scrollbar-track {
            background: var(--dark-surface);
            border-radius: 3px;
        }

        *::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--neon-pink), var(--neon-purple));
            border-radius: 3px;
            box-shadow: 0 0 10px var(--neon-pink);
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background: var(--dark-bg);
            min-height: 100vh;
            min-height: 100dvh;
            overflow-x: hidden;
        }

        .vhs-font {
            font-family: 'VT323', monospace;
        }

        .pixel-font {
            font-family: 'Press Start 2P', cursive;
        }

        /* Floating particles */
        .particles {
            position: fixed;
            inset: 0;
            z-index: -1;
            overflow: hidden;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--neon-pink);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--neon-pink), 0 0 20px var(--neon-pink);
            animation: floatParticle 15s infinite ease-in-out;
        }

        .particle:nth-child(2n) {
            background: var(--neon-blue);
            box-shadow: 0 0 10px var(--neon-blue), 0 0 20px var(--neon-blue);
            animation-duration: 20s;
        }

        .particle:nth-child(3n) {
            background: var(--neon-purple);
            box-shadow: 0 0 10px var(--neon-purple), 0 0 20px var(--neon-purple);
            animation-duration: 18s;
        }

        .particle:nth-child(4n) {
            width: 2px;
            height: 2px;
            animation-duration: 25s;
        }

        @keyframes floatParticle {

            0%,
            100% {
                transform: translateY(100vh) translateX(0) scale(0);
                opacity: 0;
            }

            10% {
                opacity: 1;
                transform: translateY(80vh) translateX(20px) scale(1);
            }

            50% {
                transform: translateY(40vh) translateX(-30px) scale(0.8);
            }

            90% {
                opacity: 1;
                transform: translateY(10vh) translateX(40px) scale(0.6);
            }

            100% {
                transform: translateY(-10vh) translateX(0) scale(0);
                opacity: 0;
            }
        }

        /* VHS noise overlay */
        .vhs-noise {
            position: fixed;
            inset: 0;
            z-index: 9999;
            pointer-events: none;
            opacity: 0.03;
            background: repeating-linear-gradient(0deg,
                    rgba(255, 255, 255, 0.1) 0px,
                    rgba(255, 255, 255, 0.1) 1px,
                    transparent 1px,
                    transparent 2px);
            animation: vhsNoise 0.2s infinite steps(10);
        }

        @keyframes vhsNoise {

            0%,
            100% {
                background-position: 0 0;
            }

            50% {
                background-position: 0 1px;
            }
        }

        /* Enhanced animated background */
        .bg-grid {
            position: fixed;
            inset: 0;
            background:
                radial-gradient(ellipse at 50% 0%, rgba(211, 0, 197, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 50%, rgba(5, 217, 232, 0.1) 0%, transparent 40%),
                radial-gradient(ellipse at 20% 80%, rgba(255, 42, 109, 0.1) 0%, transparent 40%),
                linear-gradient(180deg, rgba(10, 1, 24, 0.98) 0%, rgba(10, 1, 24, 0.85) 50%, rgba(10, 1, 24, 0.95) 100%),
                repeating-linear-gradient(90deg, transparent 0, rgba(5, 217, 232, 0.03) 1px, transparent 1px, transparent 80px),
                repeating-linear-gradient(0deg, transparent 0, rgba(255, 42, 109, 0.03) 1px, transparent 1px, transparent 80px);
            z-index: -2;
            animation: bgPulse 8s ease-in-out infinite;
        }

        @keyframes bgPulse {

            0%,
            100% {
                filter: brightness(1);
            }

            50% {
                filter: brightness(1.1);
            }
        }

        .retro-sun {
            position: fixed;
            bottom: -180px;
            left: 50%;
            transform: translateX(-50%);
            width: 450px;
            height: 450px;
            background: linear-gradient(180deg,
                    #ffe66d 0%,
                    #ffb347 15%,
                    #ff6b6b 30%,
                    #ff2a6d 50%,
                    #d300c5 70%,
                    #6a0dad 85%,
                    #2d0a4e 100%);
            border-radius: 50%;
            z-index: -1;
            opacity: 0.5;
            filter: blur(3px);
            animation: sunPulse 4s ease-in-out infinite;
        }

        @keyframes sunPulse {

            0%,
            100% {
                opacity: 0.4;
                transform: translateX(-50%) scale(1);
            }

            50% {
                opacity: 0.55;
                transform: translateX(-50%) scale(1.02);
            }
        }

        @media (min-width: 768px) {
            .retro-sun {
                width: 600px;
                height: 600px;
                bottom: -200px;
                opacity: 0.5;
            }
        }

        .retro-sun::before {
            content: '';
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(0deg,
                    transparent 0px,
                    transparent 8px,
                    rgba(10, 1, 24, 0.7) 8px,
                    rgba(10, 1, 24, 0.7) 12px);
            border-radius: 50%;
        }

        .retro-sun::after {
            content: '';
            position: absolute;
            inset: -20px;
            background: radial-gradient(circle, rgba(255, 230, 109, 0.3) 0%, transparent 70%);
            border-radius: 50%;
            animation: sunGlow 3s ease-in-out infinite alternate;
        }

        @keyframes sunGlow {
            0% {
                opacity: 0.5;
                transform: scale(1);
            }

            100% {
                opacity: 0.8;
                transform: scale(1.1);
            }
        }

        .perspective-grid {
            position: fixed;
            bottom: 0;
            left: -50%;
            right: -50%;
            height: 35vh;
            background:
                repeating-linear-gradient(90deg, rgba(5, 217, 232, 0.2) 0, rgba(5, 217, 232, 0.2) 1px, transparent 1px, transparent 60px),
                repeating-linear-gradient(180deg, rgba(255, 42, 109, 0.15) 0, rgba(255, 42, 109, 0.15) 1px, transparent 1px, transparent 40px);
            transform: perspective(400px) rotateX(70deg);
            transform-origin: center top;
            z-index: -1;
            animation: gridMove 15s linear infinite;
            mask-image: linear-gradient(180deg, transparent 0%, white 30%);
            -webkit-mask-image: linear-gradient(180deg, transparent 0%, white 30%);
        }

        @keyframes gridMove {
            0% {
                background-position: 0 0, 0 0;
            }

            100% {
                background-position: 60px 0, 0 400px;
            }
        }

        /* Neon glow effects - enhanced */
        .neon-text-pink {
            text-shadow:
                0 0 5px var(--neon-pink),
                0 0 10px var(--neon-pink),
                0 0 20px var(--neon-pink),
                0 0 40px var(--neon-pink);
            animation: neonFlicker 3s infinite;
        }

        @keyframes neonFlicker {

            0%,
            19%,
            21%,
            23%,
            25%,
            54%,
            56%,
            100% {
                text-shadow:
                    0 0 5px var(--neon-pink),
                    0 0 10px var(--neon-pink),
                    0 0 20px var(--neon-pink),
                    0 0 40px var(--neon-pink);
            }

            20%,
            24%,
            55% {
                text-shadow: none;
            }
        }

        @media (min-width: 768px) {
            .neon-text-pink {
                text-shadow:
                    0 0 5px var(--neon-pink),
                    0 0 10px var(--neon-pink),
                    0 0 20px var(--neon-pink),
                    0 0 40px var(--neon-pink),
                    0 0 80px var(--neon-pink);
            }
        }

        .neon-text-blue {
            text-shadow:
                0 0 5px var(--neon-blue),
                0 0 10px var(--neon-blue),
                0 0 20px var(--neon-blue),
                0 0 40px var(--neon-blue);
        }

        /* Gradient text */
        .gradient-text {
            background: linear-gradient(90deg, var(--neon-pink), var(--neon-purple), var(--neon-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            background-size: 200% auto;
            animation: gradientShift 3s ease-in-out infinite;
        }

        @keyframes gradientShift {

            0%,
            100% {
                background-position: 0% center;
            }

            50% {
                background-position: 100% center;
            }
        }

        /* Cards and panels - enhanced */
        .glass-panel {
            background: linear-gradient(135deg, rgba(26, 10, 46, 0.9) 0%, rgba(22, 8, 42, 0.95) 100%);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 42, 109, 0.3);
            border-radius: 16px;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.05),
                0 0 0 1px rgba(255, 42, 109, 0.1);
            position: relative;
            overflow: hidden;
        }

        .glass-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 42, 109, 0.5), rgba(5, 217, 232, 0.5), transparent);
        }

        .tool-section {
            background: linear-gradient(180deg, rgba(21, 10, 40, 0.8) 0%, rgba(10, 1, 24, 0.6) 100%);
            border: 1px solid rgba(5, 217, 232, 0.2);
            border-radius: 12px;
            position: relative;
            transition: all 0.3s ease;
        }

        .tool-section:hover {
            border-color: rgba(5, 217, 232, 0.4);
            box-shadow: 0 0 20px rgba(5, 217, 232, 0.1);
        }

        .tool-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 20%;
            right: 20%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(5, 217, 232, 0.3), transparent);
        }

        /* Buttons - Enhanced with animations */
        .btn-neon {
            background: linear-gradient(135deg, rgba(255, 42, 109, 0.15) 0%, rgba(211, 0, 197, 0.15) 100%);
            border: 1px solid var(--neon-pink);
            color: white;
            padding: 10px 16px;
            border-radius: 8px;
            font-family: 'VT323', monospace;
            font-size: 14px;
            letter-spacing: 1px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 0 10px rgba(255, 42, 109, 0.5);
        }

        .btn-neon::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .btn-neon:hover::before {
            left: 100%;
        }

        @media (min-width: 768px) {
            .btn-neon {
                font-size: 16px;
                padding: 8px 16px;
                min-height: auto;
            }
        }

        .btn-neon:hover,
        .btn-neon:active {
            background: linear-gradient(135deg, rgba(255, 42, 109, 0.35) 0%, rgba(211, 0, 197, 0.35) 100%);
            box-shadow:
                0 0 20px rgba(255, 42, 109, 0.4),
                0 0 40px rgba(255, 42, 109, 0.2),
                inset 0 0 20px rgba(255, 42, 109, 0.1);
            transform: translateY(-2px);
            border-color: var(--neon-pink);
        }

        .btn-neon.active {
            background: linear-gradient(135deg, var(--neon-pink) 0%, var(--neon-purple) 100%);
            box-shadow:
                0 0 20px rgba(255, 42, 109, 0.6),
                0 0 40px rgba(255, 42, 109, 0.3);
        }

        .btn-icon {
            background: linear-gradient(180deg, rgba(5, 217, 232, 0.15) 0%, rgba(5, 217, 232, 0.05) 100%);
            border: 1px solid rgba(5, 217, 232, 0.4);
            color: var(--neon-blue);
            width: 44px;
            height: 44px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 18px;
            flex-shrink: 0;
            position: relative;
        }

        .btn-icon::after {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--neon-blue), var(--neon-pink));
            opacity: 0;
            z-index: -1;
            transition: opacity 0.3s;
        }

        .btn-icon:hover,
        .btn-icon:active {
            background: rgba(5, 217, 232, 0.25);
            box-shadow:
                0 0 20px rgba(5, 217, 232, 0.4),
                inset 0 0 15px rgba(5, 217, 232, 0.1);
            transform: translateY(-2px) scale(1.05);
        }

        .btn-icon.active {
            background: linear-gradient(135deg, var(--neon-blue) 0%, var(--neon-purple) 100%);
            color: var(--dark-bg);
            box-shadow: 0 0 25px rgba(5, 217, 232, 0.6);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--neon-pink) 0%, var(--neon-purple) 50%, var(--neon-blue) 100%);
            background-size: 200% auto;
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 10px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            font-size: 12px;
            letter-spacing: 1px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 4px 15px rgba(255, 42, 109, 0.4),
                0 0 30px rgba(255, 42, 109, 0.2);
            min-height: 44px;
            position: relative;
            overflow: hidden;
        }

        .btn-primary::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            100% {
                left: 100%;
            }
        }

        .btn-primary:hover {
            background-position: right center;
            box-shadow:
                0 6px 25px rgba(255, 42, 109, 0.5),
                0 0 50px rgba(255, 42, 109, 0.3);
            transform: translateY(-3px);
        }

        @media (min-width: 768px) {
            .btn-primary {
                font-size: 14px;
                letter-spacing: 2px;
                padding: 12px 24px;
            }
        }

        .btn-primary:active {
            transform: scale(0.98) translateY(0);
        }

        /* Sliders - Touch optimized */
        .slider-wrapper {
            position: relative;
            padding: 4px 0;
        }

        .slider-wrapper input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: linear-gradient(90deg, var(--dark-surface) 0%, var(--dark-surface) 100%);
            border-radius: 4px;
            outline: none;
            border: 1px solid rgba(5, 217, 232, 0.2);
        }

        .slider-wrapper input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, var(--neon-blue), var(--neon-pink));
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--neon-blue);
        }

        .slider-wrapper input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, var(--neon-blue), var(--neon-pink));
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--neon-blue);
            border: none;
        }

        /* Canvas area - CRT effect */
        .canvas-wrapper {
            background:
                linear-gradient(45deg, rgba(10, 1, 24, 0.9) 25%, transparent 25%),
                linear-gradient(-45deg, rgba(10, 1, 24, 0.9) 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, rgba(10, 1, 24, 0.9) 75%),
                linear-gradient(-45deg, transparent 75%, rgba(10, 1, 24, 0.9) 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #050010;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            box-shadow:
                inset 0 0 100px rgba(0, 0, 0, 0.5),
                inset 0 0 50px rgba(5, 217, 232, 0.05),
                0 0 30px rgba(0, 0, 0, 0.5);
        }

        .canvas-wrapper::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0, 0, 0, 0.3) 100%);
            pointer-events: none;
            z-index: 5;
        }

        .canvas-wrapper::after {
            content: '';
            position: absolute;
            inset: 0;
            background:
                repeating-linear-gradient(0deg,
                    transparent 0px,
                    transparent 2px,
                    rgba(0, 0, 0, 0.03) 2px,
                    rgba(0, 0, 0, 0.03) 4px);
            pointer-events: none;
            z-index: 6;
            animation: scanMove 10s linear infinite;
        }

        @keyframes scanMove {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: 0 100px;
            }
        }

        /* Tabs */
        .tab-btn {
            padding: 12px 12px;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'VT323', monospace;
            font-size: 16px;
            letter-spacing: 1px;
            transition: all 0.2s ease;
            position: relative;
            white-space: nowrap;
            min-height: 44px;
        }

        @media (min-width: 768px) {
            .tab-btn {
                padding: 10px 16px;
                font-size: 18px;
            }
        }

        .tab-btn:hover,
        .tab-btn:active {
            color: var(--neon-blue);
        }

        .tab-btn.active {
            color: var(--neon-pink);
        }

        .tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--neon-pink);
            box-shadow: 0 0 10px var(--neon-pink);
        }

        /* Effect cards - Enhanced with hover effects */
        .effect-card {
            background: linear-gradient(180deg, rgba(21, 10, 40, 0.8) 0%, rgba(10, 1, 24, 0.6) 100%);
            border: 1px solid rgba(255, 42, 109, 0.25);
            border-radius: 12px;
            padding: 14px 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-height: 75px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .effect-card::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, rgba(255, 42, 109, 0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .effect-card:hover::before {
            opacity: 1;
        }

        .effect-card:hover {
            transform: translateY(-4px) scale(1.02);
            border-color: var(--neon-pink);
            box-shadow:
                0 8px 25px rgba(255, 42, 109, 0.3),
                0 0 30px rgba(255, 42, 109, 0.15),
                inset 0 0 20px rgba(255, 42, 109, 0.05);
        }

        .effect-card:hover .text-2xl {
            transform: scale(1.2);
            filter: drop-shadow(0 0 10px rgba(255, 42, 109, 0.5));
        }

        .effect-card .text-2xl {
            transition: all 0.3s ease;
        }

        .effect-card:active {
            transform: scale(0.95);
            border-color: var(--neon-pink);
            box-shadow: 0 0 30px rgba(255, 42, 109, 0.4);
        }

        .effect-card.active {
            border-color: var(--neon-blue);
            background: linear-gradient(180deg, rgba(5, 217, 232, 0.2) 0%, rgba(5, 217, 232, 0.05) 100%);
            box-shadow:
                0 0 25px rgba(5, 217, 232, 0.4),
                inset 0 0 30px rgba(5, 217, 232, 0.1);
        }

        /* Scanline effect */
        .scanlines::after {
            content: '';
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(0deg,
                    rgba(0, 0, 0, 0.1) 0px,
                    rgba(0, 0, 0, 0.1) 1px,
                    transparent 1px,
                    transparent 2px);
            pointer-events: none;
        }

        /* VHS timestamp style - enhanced */
        .vhs-display {
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.8) 0%, rgba(20, 10, 30, 0.9) 100%);
            border: 1px solid rgba(255, 230, 109, 0.4);
            border-radius: 6px;
            padding: 6px 12px;
            font-family: 'VT323', monospace;
            color: var(--neon-yellow);
            text-shadow: 0 0 10px var(--neon-yellow), 0 0 20px rgba(255, 230, 109, 0.5);
            font-size: 13px;
            letter-spacing: 2px;
            box-shadow:
                0 0 15px rgba(255, 230, 109, 0.2),
                inset 0 0 10px rgba(255, 230, 109, 0.05);
            animation: vhsPulse 2s ease-in-out infinite;
        }

        @keyframes vhsPulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.8;
            }
        }

        @media (min-width: 768px) {
            .vhs-display {
                padding: 8px 16px;
                font-size: 15px;
            }
        }

        /* Animations */
        @keyframes flicker {

            0%,
            100% {
                opacity: 1;
            }

            92% {
                opacity: 1;
            }

            93% {
                opacity: 0.8;
            }

            94% {
                opacity: 1;
            }

            95% {
                opacity: 0.9;
            }
        }

        .flicker {
            animation: flicker 3s infinite;
        }

        /* Hide scrollbar for tab container */
        .hide-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .hide-scrollbar::-webkit-scrollbar {
            display: none;
        }

        /* Upload area - enhanced */
        .upload-zone {
            border: 2px dashed rgba(5, 217, 232, 0.5);
            border-radius: 20px;
            background:
                radial-gradient(ellipse at center, rgba(5, 217, 232, 0.05) 0%, transparent 70%),
                rgba(5, 217, 232, 0.02);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .upload-zone::before {
            content: '';
            position: absolute;
            inset: 0;
            background:
                conic-gradient(from 0deg at 50% 50%,
                    transparent 0deg,
                    rgba(5, 217, 232, 0.1) 60deg,
                    transparent 120deg,
                    rgba(255, 42, 109, 0.1) 180deg,
                    transparent 240deg,
                    rgba(211, 0, 197, 0.1) 300deg,
                    transparent 360deg);
            animation: uploadRotate 20s linear infinite;
            opacity: 0.5;
        }

        @keyframes uploadRotate {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .upload-zone:hover,
        .upload-zone.dragover {
            border-color: var(--neon-pink);
            background:
                radial-gradient(ellipse at center, rgba(255, 42, 109, 0.1) 0%, transparent 70%),
                rgba(255, 42, 109, 0.03);
            box-shadow:
                0 0 40px rgba(255, 42, 109, 0.3),
                inset 0 0 60px rgba(255, 42, 109, 0.05);
            transform: scale(1.01);
        }

        .upload-zone:hover::before {
            opacity: 0.8;
            animation-duration: 10s;
        }

        /* History buttons */
        .history-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            padding: 8px 10px;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 12px;
            min-height: 36px;
        }

        @media (min-width: 768px) {
            .history-btn {
                padding: 8px 12px;
                font-size: 14px;
            }
        }

        .history-btn:active:not(:disabled) {
            background: rgba(5, 217, 232, 0.1);
            border-color: var(--neon-blue);
            color: var(--neon-blue);
        }

        .history-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Color picker wrapper */
        .color-picker-wrapper {
            position: relative;
            width: 44px;
            height: 44px;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid var(--neon-blue);
            flex-shrink: 0;
        }

        .color-picker-wrapper input[type="color"] {
            position: absolute;
            inset: -10px;
            width: calc(100% + 20px);
            height: calc(100% + 20px);
            cursor: pointer;
            border: none;
        }

        /* Mobile Bottom Navigation */
        .mobile-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, rgba(13, 2, 33, 0.95) 0%, rgba(22, 8, 42, 1) 100%);
            border-top: 1px solid rgba(255, 42, 109, 0.3);
            padding: 8px 12px;
            padding-bottom: max(8px, env(safe-area-inset-bottom));
            z-index: 100;
            display: flex;
            justify-content: space-around;
            align-items: center;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.5);
        }

        @media (min-width: 1024px) {
            .mobile-nav {
                display: none;
            }
        }

        .mobile-nav-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px 12px;
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 10px;
            font-family: 'VT323', monospace;
            transition: all 0.2s;
            border: none;
            background: transparent;
        }

        .mobile-nav-btn.active {
            color: var(--neon-pink);
            background: rgba(255, 42, 109, 0.1);
        }

        .mobile-nav-btn span:first-child {
            font-size: 20px;
        }

        /* Mobile Panel Overlay */
        .mobile-panel-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 90;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .mobile-panel-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        /* Mobile Slide-up Panel */
        .mobile-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            max-height: 70vh;
            background: linear-gradient(180deg, rgba(26, 10, 46, 0.98) 0%, rgba(22, 8, 42, 1) 100%);
            border-top: 1px solid rgba(255, 42, 109, 0.3);
            border-radius: 20px 20px 0 0;
            z-index: 95;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            overflow: hidden;
            padding-bottom: max(60px, calc(60px + env(safe-area-inset-bottom)));
        }

        .mobile-panel.active {
            transform: translateY(0);
        }

        .mobile-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            border-bottom: 1px solid rgba(255, 42, 109, 0.2);
            position: sticky;
            top: 0;
            background: inherit;
            z-index: 10;
        }

        .mobile-panel-content {
            padding: 16px;
            overflow-y: auto;
            max-height: calc(70vh - 60px - 60px);
        }

        .panel-handle {
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            margin: 0 auto 8px;
        }

        /* Desktop sidebar - hide on mobile */
        @media (max-width: 1023px) {
            .desktop-sidebar {
                display: none !important;
            }

            main {
                padding-bottom: 80px;
            }
        }

        /* Input styling for mobile */
        input[type="text"],
        input[type="number"],
        select {
            font-size: 16px !important;
        }

        /* Safe area padding for mobile */
        .safe-bottom {
            padding-bottom: max(16px, env(safe-area-inset-bottom));
        }

        /* Checkbox styling */
        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .checkbox-wrapper:active {
            background: rgba(255, 42, 109, 0.1);
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: var(--neon-pink);
        }

        /* Crop overlay */
        .crop-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 50;
            display: none;
        }

        .crop-overlay.active {
            display: block;
        }

        .crop-box {
            position: absolute;
            border: 2px dashed var(--neon-pink);
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6);
            cursor: move;
        }

        .crop-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: var(--neon-blue);
            border: 2px solid white;
            border-radius: 50%;
        }

        .crop-handle.nw {
            top: -10px;
            left: -10px;
            cursor: nw-resize;
        }

        .crop-handle.ne {
            top: -10px;
            right: -10px;
            cursor: ne-resize;
        }

        .crop-handle.sw {
            bottom: -10px;
            left: -10px;
            cursor: sw-resize;
        }

        .crop-handle.se {
            bottom: -10px;
            right: -10px;
            cursor: se-resize;
        }

        /* Before/After comparison */
        .compare-container {
            position: absolute;
            inset: 0;
            overflow: hidden;
            display: none;
        }

        .compare-container.active {
            display: block;
        }

        .compare-before {
            position: absolute;
            inset: 0;
            overflow: hidden;
        }

        .compare-slider {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 4px;
            background: var(--neon-pink);
            cursor: ew-resize;
            z-index: 10;
            box-shadow: 0 0 10px var(--neon-pink);
        }

        .compare-slider::before {
            content: '‚óÄ ‚ñ∂';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--neon-pink);
            color: white;
            padding: 8px 4px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
        }

        .compare-label {
            position: absolute;
            top: 10px;
            padding: 4px 12px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
            font-family: 'VT323', monospace;
            font-size: 14px;
        }

        .compare-label.before {
            left: 10px;
            color: var(--neon-yellow);
        }

        .compare-label.after {
            right: 10px;
            color: var(--neon-blue);
        }

        /* Effect intensity indicator */
        .intensity-badge {
            position: absolute;
            top: 4px;
            right: 4px;
            background: var(--neon-purple);
            color: white;
            font-size: 9px;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'VT323', monospace;
        }

        /* Crop modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 200;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: var(--dark-surface);
            border: 1px solid var(--neon-pink);
            border-radius: 16px;
            padding: 20px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            box-shadow: 0 0 40px rgba(255, 42, 109, 0.3);
        }

        /* Aspect ratio buttons */
        .aspect-btn {
            padding: 8px 16px;
            background: rgba(5, 217, 232, 0.1);
            border: 1px solid rgba(5, 217, 232, 0.3);
            border-radius: 6px;
            color: var(--neon-blue);
            font-family: 'VT323', monospace;
            font-size: 14px;
            transition: all 0.2s;
        }

        .aspect-btn:hover,
        .aspect-btn.active {
            background: var(--neon-blue);
            color: var(--dark-bg);
        }

        /* Gradient overlay buttons */
        .gradient-btn {
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'VT323', monospace;
            font-size: 12px;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.2s;
            min-height: 36px;
        }

        .gradient-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        .sunset-grad {
            background: linear-gradient(135deg, #ff6b35, #f7931e, #ffcc02);
        }

        .vapor-grad {
            background: linear-gradient(135deg, #ff71ce, #01cdfe, #05ffa1);
        }

        .neon-grad {
            background: linear-gradient(135deg, #ff2a6d, #d300c5, #05d9e8);
        }

        .miami-grad {
            background: linear-gradient(135deg, #f953c6, #b91d73);
        }

        .cyber-grad {
            background: linear-gradient(135deg, #00d2ff, #3a7bd5, #6a11cb);
        }

        .retro-grad {
            background: linear-gradient(135deg, #fc466b, #3f5efb);
        }

        /* Sticker being placed */
        .sticker-preview {
            position: absolute;
            font-size: 48px;
            cursor: move;
            z-index: 60;
            filter: drop-shadow(0 0 10px rgba(255, 42, 109, 0.5));
            user-select: none;
            transition: transform 0.1s;
        }

        .sticker-preview:hover {
            transform: scale(1.1);
        }

        /* Geometric shapes modal */
        .shape-picker {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .shape-btn {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(5, 217, 232, 0.1);
            border: 1px solid rgba(5, 217, 232, 0.3);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .shape-btn:hover {
            background: rgba(255, 42, 109, 0.2);
            border-color: var(--neon-pink);
        }

        .shape-btn svg {
            width: 30px;
            height: 30px;
            stroke: var(--neon-pink);
            fill: none;
            stroke-width: 2;
        }

        /* Auto enhance animation */
        @keyframes enhanceGlow {
            0% {
                box-shadow: 0 0 5px var(--neon-blue);
            }

            50% {
                box-shadow: 0 0 30px var(--neon-blue), 0 0 60px var(--neon-pink);
            }

            100% {
                box-shadow: 0 0 5px var(--neon-blue);
            }
        }

        .enhancing {
            animation: enhanceGlow 1s ease-in-out;
        }
    </style>
</head>

<body class="text-white min-h-screen">
    <!-- VHS Noise Overlay -->
    <div class="vhs-noise"></div>

    <!-- Floating Particles -->
    <div class="particles" id="particles"></div>

    <!-- Background elements -->
    <div class="bg-grid"></div>
    <div class="retro-sun"></div>
    <div class="perspective-grid"></div>

    <!-- Header -->
    <header class="relative z-10 px-3 sm:px-6 py-3 sm:py-4 border-b border-pink-500/30"
        style="background: linear-gradient(180deg, rgba(21, 10, 40, 0.8) 0%, transparent 100%);">
        <div class="max-w-screen-2xl mx-auto flex items-center justify-between">
            <div class="flex items-center gap-2 sm:gap-4">
                <div class="text-2xl sm:text-4xl" style="filter: drop-shadow(0 0 10px rgba(255, 42, 109, 0.5));">üìº
                </div>
                <div>
                    <h1 class="text-lg sm:text-2xl font-black tracking-wider gradient-text"
                        style="font-size: clamp(1.1rem, 4vw, 1.75rem);">NEON MEMORIES</h1>
                    <p class="vhs-font text-xs sm:text-sm text-cyan-400 hidden sm:block neon-text-blue"
                        style="opacity: 0.9;">RETRO PHOTO EDITOR ‚Ä¢ EST. 1985</p>
                </div>
            </div>

            <div class="flex items-center gap-2 sm:gap-4">
                <div class="vhs-display hidden md:block">
                    <span id="timestamp">JAN 01 1989 00:00:00</span>
                </div>
                <div class="flex items-center gap-1 sm:gap-2">
                    <button onclick="undo()" id="undoBtn" class="history-btn vhs-font" disabled>
                        ‚Ü∂ <span class="hidden sm:inline">UNDO</span>
                    </button>
                    <button onclick="redo()" id="redoBtn" class="history-btn vhs-font" disabled>
                        <span class="hidden sm:inline">REDO</span> ‚Ü∑
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="relative z-10 max-w-screen-2xl mx-auto p-3 sm:p-4 lg:p-6">
        <div class="grid lg:grid-cols-12 gap-4 lg:gap-6">

            <!-- Left Sidebar - Tools (Desktop only) -->
            <aside class="lg:col-span-3 xl:col-span-2 desktop-sidebar">
                <div class="glass-panel p-4 space-y-4 sticky top-4">
                    <h2 class="vhs-font text-xl text-cyan-400 neon-text-blue flex items-center gap-2">
                        <span>üîß</span> TOOLS
                    </h2>

                    <!-- Transform Tools -->
                    <div class="tool-section p-3">
                        <h3 class="vhs-font text-sm text-pink-400 mb-3">TRANSFORM</h3>
                        <div class="grid grid-cols-4 gap-2 mb-2">
                            <button onclick="rotateImage(-90)" class="btn-icon" title="Rotate Left">‚Ü∫</button>
                            <button onclick="rotateImage(90)" class="btn-icon" title="Rotate Right">‚Üª</button>
                            <button onclick="flipImage('h')" class="btn-icon" title="Flip Horizontal">‚áÜ</button>
                            <button onclick="flipImage('v')" class="btn-icon" title="Flip Vertical">‚áÖ</button>
                        </div>
                        <button onclick="openCropModal()" class="btn-neon w-full mt-2">‚úÇÔ∏è CROP</button>
                    </div>

                    <!-- Drawing Tools -->
                    <div class="tool-section p-3">
                        <h3 class="vhs-font text-sm text-pink-400 mb-3">DRAW</h3>
                        <div class="flex items-center gap-2 mb-3">
                            <button onclick="setTool('brush')" class="btn-icon flex-1" id="brushTool">üñåÔ∏è</button>
                            <button onclick="setTool('eraser')" class="btn-icon flex-1" id="eraserTool">üßπ</button>
                            <div class="color-picker-wrapper">
                                <input type="color" id="brushColor" value="#ff2a6d">
                            </div>
                        </div>
                        <div class="slider-wrapper">
                            <label class="vhs-font text-xs text-gray-400">BRUSH SIZE</label>
                            <input type="range" id="brushSize" min="1" max="50" value="5">
                        </div>
                    </div>

                    <!-- Text Tool -->
                    <div class="tool-section p-3">
                        <h3 class="vhs-font text-sm text-pink-400 mb-3">TEXT</h3>
                        <input type="text" id="textInput" placeholder="Enter text..."
                            class="w-full bg-black/50 border border-cyan-500/30 rounded px-3 py-2 text-sm mb-2 focus:border-pink-500 focus:outline-none">
                        <div class="flex gap-2 mb-2">
                            <select id="textFont"
                                class="flex-1 bg-black/50 border border-cyan-500/30 rounded px-2 py-2 text-xs">
                                <option value="VT323">VHS</option>
                                <option value="Orbitron">RETRO</option>
                                <option value="Press Start 2P">PIXEL</option>
                            </select>
                            <input type="number" id="textSize" value="32" min="8" max="120"
                                class="w-16 bg-black/50 border border-cyan-500/30 rounded px-2 py-2 text-xs">
                        </div>
                        <button onclick="addText()" class="btn-neon w-full">ADD TEXT</button>
                    </div>

                    <!-- Compare Tool -->
                    <div class="tool-section p-3">
                        <h3 class="vhs-font text-sm text-pink-400 mb-3">COMPARE</h3>
                        <button onclick="toggleCompare()" id="compareBtn" class="btn-neon w-full">üëÅÔ∏è BEFORE /
                            AFTER</button>
                    </div>

                    <!-- Auto Enhance -->
                    <div class="tool-section p-3">
                        <h3 class="vhs-font text-sm text-pink-400 mb-3">‚ú® MAGIC</h3>
                        <button onclick="autoEnhance()" class="btn-primary w-full">‚ö° AUTO ENHANCE</button>
                    </div>

                    <!-- Stickers -->
                    <div class="tool-section p-3">
                        <h3 class="vhs-font text-sm text-pink-400 mb-3">üé® STICKERS</h3>
                        <div class="grid grid-cols-4 gap-2">
                            <button onclick="addSticker('cassette')" class="btn-icon text-lg"
                                title="Cassette">üìº</button>
                            <button onclick="addSticker('palm')" class="btn-icon text-lg" title="Palm Tree">üå¥</button>
                            <button onclick="addSticker('flamingo')" class="btn-icon text-lg"
                                title="Flamingo">ü¶©</button>
                            <button onclick="addSticker('sun')" class="btn-icon text-lg" title="Sun">üåÖ</button>
                            <button onclick="addSticker('star')" class="btn-icon text-lg" title="Star">‚≠ê</button>
                            <button onclick="addSticker('heart')" class="btn-icon text-lg" title="Heart">üíú</button>
                            <button onclick="addSticker('diamond')" class="btn-icon text-lg" title="Diamond">üíé</button>
                            <button onclick="addSticker('lightning')" class="btn-icon text-lg"
                                title="Lightning">‚ö°</button>
                        </div>
                        <div class="flex gap-2 mt-2">
                            <button onclick="addGeometricShape()" class="btn-neon flex-1">‚óá SHAPE</button>
                            <button onclick="document.getElementById('customStickerInput').click()"
                                class="btn-neon flex-1">üìÅ CUSTOM</button>
                        </div>
                        <input type="file" id="customStickerInput" accept="image/*" class="hidden"
                            onchange="handleCustomStickerUpload(event)">
                        <button onclick="flattenLayers()" class="btn-primary w-full mt-2" id="flattenBtn">‚úì FLATTEN
                            LAYERS</button>
                    </div>

                    <!-- Gradient Overlays -->
                    <div class="tool-section p-3">
                        <h3 class="vhs-font text-sm text-pink-400 mb-3">üåà GRADIENTS</h3>
                        <div class="grid grid-cols-2 gap-2">
                            <button onclick="applyGradientOverlay('sunset')"
                                class="gradient-btn sunset-grad">SUNSET</button>
                            <button onclick="applyGradientOverlay('vaporwave')"
                                class="gradient-btn vapor-grad">VAPOR</button>
                            <button onclick="applyGradientOverlay('neon')" class="gradient-btn neon-grad">NEON</button>
                            <button onclick="applyGradientOverlay('miami')"
                                class="gradient-btn miami-grad">MIAMI</button>
                            <button onclick="applyGradientOverlay('cyber')"
                                class="gradient-btn cyber-grad">CYBER</button>
                            <button onclick="applyGradientOverlay('retro')"
                                class="gradient-btn retro-grad">RETRO</button>
                        </div>
                    </div>
                </div>
            </aside>

            <!-- Center - Canvas -->
            <section class="lg:col-span-6 xl:col-span-7">
                <div class="glass-panel p-3 sm:p-4">
                    <!-- Toolbar -->
                    <div class="flex items-center justify-between mb-3 sm:mb-4 flex-wrap gap-2">
                        <div class="flex items-center gap-1 sm:gap-2">
                            <button onclick="zoomCanvas(-0.1)"
                                class="btn-icon text-sm w-10 h-10 sm:w-11 sm:h-11">‚àí</button>
                            <span class="vhs-font text-cyan-400 min-w-[50px] sm:min-w-[60px] text-center text-sm"
                                id="zoomLevel">100%</span>
                            <button onclick="zoomCanvas(0.1)"
                                class="btn-icon text-sm w-10 h-10 sm:w-11 sm:h-11">+</button>
                            <button onclick="resetZoom()" class="btn-icon text-sm w-10 h-10 sm:w-11 sm:h-11">‚ü≤</button>
                        </div>
                        <div class="flex items-center gap-2">
                            <button onclick="toggleCompare()" id="compareBtnMobile"
                                class="btn-icon text-sm w-10 h-10 sm:w-11 sm:h-11 lg:hidden"
                                title="Compare">üëÅÔ∏è</button>
                            <button onclick="document.getElementById('fileInput').click()"
                                class="btn-primary text-xs sm:text-sm">
                                üìÅ <span class="hidden xs:inline">LOAD</span> IMAGE
                            </button>
                            <input type="file" id="fileInput" accept="image/*" class="hidden">
                        </div>
                    </div>

                    <!-- Canvas Container -->
                    <div class="canvas-wrapper scanlines relative min-h-[250px] sm:min-h-[350px] lg:min-h-[450px] flex items-center justify-center"
                        id="canvasContainer">
                        <canvas id="photoCanvas" class="max-w-full max-h-full hidden"></canvas>
                        <canvas id="originalCanvas" class="hidden"></canvas>

                        <!-- Before/After Comparison -->
                        <div class="compare-container" id="compareContainer">
                            <img id="compareAfter" class="absolute inset-0 w-full h-full object-contain">
                            <div class="compare-before" id="compareBefore">
                                <img id="compareBeforeImg" class="absolute inset-0 w-full h-full object-contain">
                            </div>
                            <div class="compare-slider" id="compareSlider" style="left: 50%;"></div>
                            <span class="compare-label before">BEFORE</span>
                            <span class="compare-label after">AFTER</span>
                        </div>

                        <!-- Upload Prompt -->
                        <div id="uploadPrompt"
                            class="upload-zone absolute inset-2 sm:inset-4 flex flex-col items-center justify-center p-4">
                            <div class="text-5xl sm:text-6xl mb-3 sm:mb-4 animate-bounce">üì∏</div>
                            <p class="vhs-font text-lg sm:text-2xl text-cyan-400 mb-1 sm:mb-2 text-center">DROP YOUR
                                PHOTO HERE</p>
                            <p class="vhs-font text-sm sm:text-lg text-pink-400 text-center">or tap LOAD IMAGE above</p>
                            <div class="mt-4 sm:mt-6 flex gap-2 sm:gap-4 vhs-font text-xs sm:text-sm text-gray-500">
                                <span>JPG</span>
                                <span>‚Ä¢</span>
                                <span>PNG</span>
                                <span>‚Ä¢</span>
                                <span>GIF</span>
                            </div>
                        </div>
                    </div>

                    <!-- Effect Intensity Slider -->
                    <div class="mt-3 sm:mt-4 p-3 tool-section" id="intensitySection" style="display: none;">
                        <div class="flex items-center justify-between mb-2">
                            <span class="vhs-font text-sm text-pink-400">üéöÔ∏è EFFECT INTENSITY</span>
                            <span class="vhs-font text-sm text-cyan-400" id="intensityVal">100%</span>
                        </div>
                        <div class="slider-wrapper">
                            <input type="range" id="effectIntensity" min="0" max="100" value="100"
                                oninput="updateIntensity()">
                        </div>
                        <div class="flex justify-between mt-2 gap-2">
                            <button onclick="applyIntensity()" class="btn-neon flex-1">‚úì APPLY</button>
                            <button onclick="cancelEffect()" class="btn-neon flex-1">‚úï CANCEL</button>
                        </div>
                    </div>

                    <!-- Bottom Actions -->
                    <div class="flex items-center justify-between mt-3 sm:mt-4 flex-wrap gap-3">
                        <div class="flex items-center gap-2 vhs-font text-xs sm:text-sm text-gray-400">
                            <span id="imageInfo">No image loaded</span>
                        </div>
                        <div class="flex items-center gap-2 flex-wrap">
                            <button onclick="openCropModal()" class="btn-neon text-xs sm:text-sm lg:hidden">‚úÇÔ∏è
                                CROP</button>
                            <button onclick="resetImage()" class="btn-neon text-xs sm:text-sm">‚Ü∫ RESET</button>
                            <button onclick="downloadImage('png')" class="btn-primary text-xs sm:text-sm">üíæ
                                SAVE</button>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Right Sidebar - Effects & Adjustments (Desktop only) -->
            <aside class="lg:col-span-3 desktop-sidebar">
                <div class="glass-panel p-4 sticky top-4">
                    <!-- Tabs -->
                    <div class="flex border-b border-pink-500/20 mb-4 overflow-x-auto hide-scrollbar">
                        <button onclick="switchTab('adjust')" class="tab-btn active" id="tabAdjust">ADJUST</button>
                        <button onclick="switchTab('effects')" class="tab-btn" id="tabEffects">EFFECTS</button>
                        <button onclick="switchTab('vintage')" class="tab-btn" id="tabVintage">VINTAGE</button>
                        <button onclick="switchTab('frames')" class="tab-btn" id="tabFrames">FRAMES</button>
                    </div>

                    <!-- Adjust Panel -->
                    <div id="panelAdjust" class="space-y-4 max-h-[55vh] overflow-y-auto pr-2">
                        <div class="slider-wrapper">
                            <div class="flex justify-between mb-1">
                                <label class="vhs-font text-sm text-pink-400">BRIGHTNESS</label>
                                <span class="vhs-font text-xs text-cyan-400" id="brightnessVal">0</span>
                            </div>
                            <input type="range" id="brightness" min="-100" max="100" value="0"
                                oninput="updateAdjustments()">
                        </div>

                        <div class="slider-wrapper">
                            <div class="flex justify-between mb-1">
                                <label class="vhs-font text-sm text-pink-400">CONTRAST</label>
                                <span class="vhs-font text-xs text-cyan-400" id="contrastVal">0</span>
                            </div>
                            <input type="range" id="contrast" min="-100" max="100" value="0"
                                oninput="updateAdjustments()">
                        </div>

                        <div class="slider-wrapper">
                            <div class="flex justify-between mb-1">
                                <label class="vhs-font text-sm text-pink-400">SATURATION</label>
                                <span class="vhs-font text-xs text-cyan-400" id="saturationVal">0</span>
                            </div>
                            <input type="range" id="saturation" min="-100" max="100" value="0"
                                oninput="updateAdjustments()">
                        </div>

                        <div class="slider-wrapper">
                            <div class="flex justify-between mb-1">
                                <label class="vhs-font text-sm text-pink-400">EXPOSURE</label>
                                <span class="vhs-font text-xs text-cyan-400" id="exposureVal">0</span>
                            </div>
                            <input type="range" id="exposure" min="-100" max="100" value="0"
                                oninput="updateAdjustments()">
                        </div>

                        <div class="slider-wrapper">
                            <div class="flex justify-between mb-1">
                                <label class="vhs-font text-sm text-pink-400">TEMPERATURE</label>
                                <span class="vhs-font text-xs text-cyan-400" id="temperatureVal">0</span>
                            </div>
                            <input type="range" id="temperature" min="-100" max="100" value="0"
                                oninput="updateAdjustments()">
                        </div>

                        <div class="slider-wrapper">
                            <div class="flex justify-between mb-1">
                                <label class="vhs-font text-sm text-pink-400">TINT</label>
                                <span class="vhs-font text-xs text-cyan-400" id="tintVal">0</span>
                            </div>
                            <input type="range" id="tint" min="-100" max="100" value="0" oninput="updateAdjustments()">
                        </div>

                        <div class="slider-wrapper">
                            <div class="flex justify-between mb-1">
                                <label class="vhs-font text-sm text-pink-400">VIGNETTE</label>
                                <span class="vhs-font text-xs text-cyan-400" id="vignetteVal">0</span>
                            </div>
                            <input type="range" id="vignette" min="0" max="100" value="0" oninput="updateAdjustments()">
                        </div>

                        <div class="slider-wrapper">
                            <div class="flex justify-between mb-1">
                                <label class="vhs-font text-sm text-pink-400">BLUR</label>
                                <span class="vhs-font text-xs text-cyan-400" id="blurVal">0</span>
                            </div>
                            <input type="range" id="blur" min="0" max="20" value="0" step="0.5"
                                oninput="updateAdjustments()">
                        </div>

                        <div class="slider-wrapper">
                            <div class="flex justify-between mb-1">
                                <label class="vhs-font text-sm text-pink-400">HUE ROTATE</label>
                                <span class="vhs-font text-xs text-cyan-400" id="hueVal">0¬∞</span>
                            </div>
                            <input type="range" id="hue" min="0" max="360" value="0" oninput="updateAdjustments()">
                        </div>
                    </div>

                    <!-- Effects Panel -->
                    <div id="panelEffects" class="hidden grid grid-cols-2 gap-2 max-h-[55vh] overflow-y-auto pr-2">
                        <div class="effect-card relative" onclick="previewEffect('vhs')">
                            <div class="text-2xl mb-1">üìº</div>
                            <div class="vhs-font text-xs">VHS</div>
                        </div>
                        <div class="effect-card relative" onclick="previewEffect('glitch')">
                            <div class="text-2xl mb-1">üëæ</div>
                            <div class="vhs-font text-xs">GLITCH</div>
                        </div>
                        <div class="effect-card relative" onclick="previewEffect('scanlines')">
                            <div class="text-2xl mb-1">üì∫</div>
                            <div class="vhs-font text-xs">SCANLINES</div>
                        </div>
                        <div class="effect-card relative" onclick="previewEffect('chromatic')">
                            <div class="text-2xl mb-1">üåà</div>
                            <div class="vhs-font text-xs">RGB SPLIT</div>
                        </div>
                        <div class="effect-card relative" onclick="previewEffect('pixelate')">
                            <div class="text-2xl mb-1">üéÆ</div>
                            <div class="vhs-font text-xs">8-BIT</div>
                        </div>
                        <div class="effect-card relative" onclick="previewEffect('neon')">
                            <div class="text-2xl mb-1">üíú</div>
                            <div class="vhs-font text-xs">NEON</div>
                        </div>
                        <div class="effect-card relative" onclick="previewEffect('cyberpunk')">
                            <div class="text-2xl mb-1">üåÉ</div>
                            <div class="vhs-font text-xs">CYBER</div>
                        </div>
                        <div class="effect-card relative" onclick="previewEffect('synthwave')">
                            <div class="text-2xl mb-1">üåÖ</div>
                            <div class="vhs-font text-xs">SYNTH</div>
                        </div>
                        <div class="effect-card relative" onclick="previewEffect('vaporwave')">
                            <div class="text-2xl mb-1">üå¥</div>
                            <div class="vhs-font text-xs">VAPOR</div>
                        </div>
                        <div class="effect-card relative" onclick="previewEffect('miami')">
                            <div class="text-2xl mb-1">üèñÔ∏è</div>
                            <div class="vhs-font text-xs">MIAMI</div>
                        </div>
                        <div class="effect-card relative" onclick="previewEffect('tokyo')">
                            <div class="text-2xl mb-1">üóº</div>
                            <div class="vhs-font text-xs">TOKYO</div>
                        </div>
                        <div class="effect-card relative" onclick="previewEffect('duotone')">
                            <div class="text-2xl mb-1">üé®</div>
                            <div class="vhs-font text-xs">DUOTONE</div>
                        </div>
                    </div>

                    <!-- Vintage Panel -->
                    <div id="panelVintage" class="hidden grid grid-cols-2 gap-2 max-h-[55vh] overflow-y-auto pr-2">
                        <div class="effect-card relative" onclick="previewVintage('sepia')">
                            <div class="text-2xl mb-1">üü§</div>
                            <div class="vhs-font text-xs">SEPIA</div>
                        </div>
                        <div class="effect-card relative" onclick="previewVintage('faded')">
                            <div class="text-2xl mb-1">üå´Ô∏è</div>
                            <div class="vhs-font text-xs">FADED</div>
                        </div>
                        <div class="effect-card relative" onclick="previewVintage('polaroid')">
                            <div class="text-2xl mb-1">üì∑</div>
                            <div class="vhs-font text-xs">POLAROID</div>
                        </div>
                        <div class="effect-card relative" onclick="previewVintage('kodak')">
                            <div class="text-2xl mb-1">üéûÔ∏è</div>
                            <div class="vhs-font text-xs">KODAK</div>
                        </div>
                        <div class="effect-card relative" onclick="previewVintage('grain')">
                            <div class="text-2xl mb-1">‚ú®</div>
                            <div class="vhs-font text-xs">GRAIN</div>
                        </div>
                        <div class="effect-card relative" onclick="previewVintage('dusty')">
                            <div class="text-2xl mb-1">üí®</div>
                            <div class="vhs-font text-xs">DUSTY</div>
                        </div>
                        <div class="effect-card relative" onclick="previewVintage('lightleak')">
                            <div class="text-2xl mb-1">‚òÄÔ∏è</div>
                            <div class="vhs-font text-xs">LEAK</div>
                        </div>
                        <div class="effect-card relative" onclick="previewVintage('oldphoto')">
                            <div class="text-2xl mb-1">üñºÔ∏è</div>
                            <div class="vhs-font text-xs">OLD</div>
                        </div>
                        <div class="effect-card relative" onclick="previewVintage('1970s')">
                            <div class="text-2xl mb-1">üï∫</div>
                            <div class="vhs-font text-xs">1970s</div>
                        </div>
                        <div class="effect-card relative" onclick="previewVintage('1980s')">
                            <div class="text-2xl mb-1">üíø</div>
                            <div class="vhs-font text-xs">1980s</div>
                        </div>
                        <div class="effect-card relative" onclick="previewVintage('1990s')">
                            <div class="text-2xl mb-1">üíæ</div>
                            <div class="vhs-font text-xs">1990s</div>
                        </div>
                        <div class="effect-card relative" onclick="previewVintage('daguerreotype')">
                            <div class="text-2xl mb-1">üèõÔ∏è</div>
                            <div class="vhs-font text-xs">ANTIQUE</div>
                        </div>
                    </div>

                    <!-- Frames Panel -->
                    <div id="panelFrames" class="hidden space-y-3 max-h-[55vh] overflow-y-auto pr-2">
                        <div class="grid grid-cols-2 gap-2">
                            <div class="effect-card" onclick="applyFrame('vhsFrame')">
                                <div class="text-2xl mb-1">üìº</div>
                                <div class="vhs-font text-xs">VHS</div>
                            </div>
                            <div class="effect-card" onclick="applyFrame('polaroidFrame')">
                                <div class="text-2xl mb-1">üñºÔ∏è</div>
                                <div class="vhs-font text-xs">POLAROID</div>
                            </div>
                            <div class="effect-card" onclick="applyFrame('neonBorder')">
                                <div class="text-2xl mb-1">üí†</div>
                                <div class="vhs-font text-xs">NEON</div>
                            </div>
                            <div class="effect-card" onclick="applyFrame('none')">
                                <div class="text-2xl mb-1">‚ùå</div>
                                <div class="vhs-font text-xs">NONE</div>
                            </div>
                        </div>

                        <div class="tool-section p-3">
                            <h3 class="vhs-font text-sm text-pink-400 mb-3">OVERLAYS</h3>
                            <div class="space-y-1">
                                <label class="checkbox-wrapper">
                                    <input type="checkbox" id="overlayTimestamp" onchange="toggleOverlay('timestamp')">
                                    <span class="vhs-font text-sm">üìÖ TIMESTAMP</span>
                                </label>
                                <label class="checkbox-wrapper">
                                    <input type="checkbox" id="overlayRec" onchange="toggleOverlay('rec')">
                                    <span class="vhs-font text-sm">üî¥ REC</span>
                                </label>
                                <label class="checkbox-wrapper">
                                    <input type="checkbox" id="overlayPlay" onchange="toggleOverlay('play')">
                                    <span class="vhs-font text-sm">‚ñ∂ PLAY</span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
            </aside>
        </div>
    </main>

    <!-- Crop Modal -->
    <div class="modal-overlay" id="cropModal">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="vhs-font text-xl text-cyan-400 neon-text-blue">‚úÇÔ∏è CROP IMAGE</h3>
                <button onclick="closeCropModal()" class="btn-icon w-10 h-10">‚úï</button>
            </div>

            <div class="mb-4">
                <p class="vhs-font text-sm text-pink-400 mb-3">ASPECT RATIO</p>
                <div class="flex flex-wrap gap-2">
                    <button onclick="setAspectRatio('free')" class="aspect-btn active" id="aspectFree">FREE</button>
                    <button onclick="setAspectRatio('1:1')" class="aspect-btn" id="aspect1_1">1:1</button>
                    <button onclick="setAspectRatio('4:3')" class="aspect-btn" id="aspect4_3">4:3</button>
                    <button onclick="setAspectRatio('16:9')" class="aspect-btn" id="aspect16_9">16:9</button>
                    <button onclick="setAspectRatio('3:2')" class="aspect-btn" id="aspect3_2">3:2</button>
                </div>
            </div>

            <div class="relative bg-black/50 rounded-lg overflow-hidden mb-4" id="cropArea" style="max-height: 50vh;">
                <canvas id="cropCanvas" class="max-w-full"></canvas>
                <div class="crop-box" id="cropBox">
                    <div class="crop-handle nw" data-handle="nw"></div>
                    <div class="crop-handle ne" data-handle="ne"></div>
                    <div class="crop-handle sw" data-handle="sw"></div>
                    <div class="crop-handle se" data-handle="se"></div>
                </div>
            </div>

            <div class="flex gap-3">
                <button onclick="applyCrop()" class="btn-primary flex-1">‚úì APPLY CROP</button>
                <button onclick="closeCropModal()" class="btn-neon flex-1">‚úï CANCEL</button>
            </div>
        </div>
    </div>

    <!-- Mobile Bottom Navigation -->
    <nav class="mobile-nav lg:hidden">
        <button class="mobile-nav-btn" onclick="openMobilePanel('tools')">
            <span>üîß</span>
            <span>TOOLS</span>
        </button>
        <button class="mobile-nav-btn" onclick="openMobilePanel('adjust')">
            <span>üéöÔ∏è</span>
            <span>ADJUST</span>
        </button>
        <button class="mobile-nav-btn" onclick="openMobilePanel('effects')">
            <span>‚ú®</span>
            <span>EFFECTS</span>
        </button>
        <button class="mobile-nav-btn" onclick="openMobilePanel('vintage')">
            <span>üì∑</span>
            <span>VINTAGE</span>
        </button>
        <button class="mobile-nav-btn" onclick="openMobilePanel('frames')">
            <span>üñºÔ∏è</span>
            <span>FRAMES</span>
        </button>
    </nav>

    <!-- Mobile Panel Overlay -->
    <div class="mobile-panel-overlay lg:hidden" id="mobilePanelOverlay" onclick="closeMobilePanel()"></div>

    <!-- Mobile Slide-up Panel -->
    <div class="mobile-panel lg:hidden" id="mobilePanel">
        <div class="panel-handle"></div>
        <div class="mobile-panel-header">
            <h3 class="vhs-font text-lg text-cyan-400" id="mobilePanelTitle">TOOLS</h3>
            <button onclick="closeMobilePanel()" class="btn-icon w-10 h-10">‚úï</button>
        </div>
        <div class="mobile-panel-content" id="mobilePanelContent">
        </div>
    </div>

    <script>
        // Main variables
        const canvas = document.getElementById('photoCanvas');
        const ctx = canvas.getContext('2d');
        const originalCanvas = document.getElementById('originalCanvas');
        const originalCtx = originalCanvas.getContext('2d');
        const fileInput = document.getElementById('fileInput');
        const uploadPrompt = document.getElementById('uploadPrompt');
        const canvasContainer = document.getElementById('canvasContainer');

        let originalImage = null;
        let workingImageData = null; // Store the working state (after adjustments, before effects)
        let beforeEffectData = null;
        let zoom = 1;
        let history = [];
        let historyIndex = -1;
        let currentTool = null;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let overlays = { timestamp: false, rec: false, play: false };
        let currentFrame = 'none';
        let activeMobilePanel = null;

        // Effect intensity
        let pendingEffect = null;
        let pendingEffectType = null;
        let effectIntensity = 100;

        // Layer system for stickers and text
        let layers = [];
        let selectedLayer = null;
        let isDraggingLayer = false;
        let isRotatingLayer = false;
        let isResizingLayer = false;
        let layerDragOffset = { x: 0, y: 0 };

        // Crop variables
        let cropAspectRatio = 'free';
        let cropBox = { x: 50, y: 50, width: 200, height: 150 };
        let isDraggingCrop = false;
        let isResizingCrop = false;
        let resizeHandle = null;
        let cropStartPos = { x: 0, y: 0 };

        // Compare mode
        let isCompareMode = false;
        let compareSliderPos = 50;

        // Generate floating particles
        function createParticles() {
            const container = document.getElementById('particles');
            const particleCount = window.innerWidth < 768 ? 15 : 30;

            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 15 + 's';
                particle.style.animationDuration = (15 + Math.random() * 15) + 's';
                container.appendChild(particle);
            }
        }
        createParticles();

        // Update timestamp
        function updateTimestamp() {
            const now = new Date();
            const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
            const year = 1985 + Math.floor(Math.random() * 10);
            const text = `${months[now.getMonth()]} ${String(now.getDate()).padStart(2, '0')} ${year} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')}`;
            const el = document.getElementById('timestamp');
            if (el) el.textContent = text;
        }
        setInterval(updateTimestamp, 1000);
        updateTimestamp();

        // File handling
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) loadImage(e.target.files[0]);
        });

        // Drag and drop
        canvasContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadPrompt.classList.add('dragover');
        });

        canvasContainer.addEventListener('dragleave', () => {
            uploadPrompt.classList.remove('dragover');
        });

        canvasContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadPrompt.classList.remove('dragover');
            if (e.dataTransfer.files[0]) loadImage(e.dataTransfer.files[0]);
        });

        uploadPrompt.addEventListener('click', () => {
            fileInput.click();
        });

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;

                    const isMobile = window.innerWidth < 768;
                    const maxWidth = isMobile ? window.innerWidth - 40 : 800;
                    const maxHeight = isMobile ? 400 : 500;
                    let width = img.width;
                    let height = img.height;

                    if (width > maxWidth) {
                        height = (maxWidth / width) * height;
                        width = maxWidth;
                    }
                    if (height > maxHeight) {
                        width = (maxHeight / height) * width;
                        height = maxHeight;
                    }

                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);

                    // Store original for comparison
                    originalCanvas.width = width;
                    originalCanvas.height = height;
                    originalCtx.drawImage(img, 0, 0, width, height);

                    // Store working image data (clean, no effects)
                    workingImageData = ctx.getImageData(0, 0, width, height);

                    canvas.classList.remove('hidden');
                    uploadPrompt.classList.add('hidden');

                    document.getElementById('imageInfo').textContent = `${Math.round(width)} √ó ${Math.round(height)} px`;

                    // Clear any layers
                    layers = [];
                    selectedLayer = null;

                    // Reset all sliders to 0 without applying effects
                    resetSlidersOnly();

                    saveToHistory();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Reset sliders without applying any effects
        function resetSlidersOnly() {
            ['brightness', 'contrast', 'saturation', 'exposure', 'temperature', 'tint', 'vignette', 'blur', 'hue'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.value = id === 'hue' ? 0 : (id === 'vignette' || id === 'blur' ? 0 : 0);

                const valEl = document.getElementById(id + 'Val');
                if (valEl) valEl.textContent = id === 'hue' ? '0¬∞' : '0';
            });
        }

        // History management
        function saveToHistory() {
            historyIndex++;
            history = history.slice(0, historyIndex);
            history.push(canvas.toDataURL());
            updateHistoryButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                loadFromHistory();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                loadFromHistory();
            }
        }

        function loadFromHistory() {
            const img = new Image();
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                updateHistoryButtons();
            };
            img.src = history[historyIndex];
        }

        function updateHistoryButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
        }

        // Compare mode
        function toggleCompare() {
            if (!originalImage) return;

            isCompareMode = !isCompareMode;
            const container = document.getElementById('compareContainer');
            const compareBtn = document.getElementById('compareBtn');
            const compareBtnMobile = document.getElementById('compareBtnMobile');

            if (isCompareMode) {
                // Set before image (original)
                document.getElementById('compareBeforeImg').src = originalCanvas.toDataURL();
                // Set after image (current)
                document.getElementById('compareAfter').src = canvas.toDataURL();

                container.classList.add('active');
                canvas.style.opacity = '0';

                if (compareBtn) compareBtn.classList.add('active');
                if (compareBtnMobile) compareBtnMobile.classList.add('active');

                updateCompareSlider(50);
            } else {
                container.classList.remove('active');
                canvas.style.opacity = '1';

                if (compareBtn) compareBtn.classList.remove('active');
                if (compareBtnMobile) compareBtnMobile.classList.remove('active');
            }
        }

        function updateCompareSlider(percent) {
            compareSliderPos = percent;
            const slider = document.getElementById('compareSlider');
            const beforeContainer = document.getElementById('compareBefore');

            slider.style.left = percent + '%';
            beforeContainer.style.clipPath = `inset(0 ${100 - percent}% 0 0)`;
        }

        // Compare slider drag
        const compareSlider = document.getElementById('compareSlider');
        compareSlider.addEventListener('mousedown', startCompareSliderDrag);
        compareSlider.addEventListener('touchstart', startCompareSliderDrag, { passive: false });

        function startCompareSliderDrag(e) {
            e.preventDefault();
            document.addEventListener('mousemove', dragCompareSlider);
            document.addEventListener('mouseup', stopCompareSliderDrag);
            document.addEventListener('touchmove', dragCompareSlider, { passive: false });
            document.addEventListener('touchend', stopCompareSliderDrag);
        }

        function dragCompareSlider(e) {
            e.preventDefault();
            const container = document.getElementById('compareContainer');
            const rect = container.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let percent = ((clientX - rect.left) / rect.width) * 100;
            percent = Math.max(0, Math.min(100, percent));
            updateCompareSlider(percent);
        }

        function stopCompareSliderDrag() {
            document.removeEventListener('mousemove', dragCompareSlider);
            document.removeEventListener('mouseup', stopCompareSliderDrag);
            document.removeEventListener('touchmove', dragCompareSlider);
            document.removeEventListener('touchend', stopCompareSliderDrag);
        }

        // Effect intensity system
        function previewEffect(effect) {
            if (!originalImage) return;

            // Store current canvas state before effect (this is what we revert to on cancel)
            beforeEffectData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            pendingEffect = effect;
            pendingEffectType = 'effect';

            // Apply effect at 100%
            applyEffectInternal(effect, 100);

            // Show intensity slider
            document.getElementById('intensitySection').style.display = 'block';
            document.getElementById('effectIntensity').value = 100;
            document.getElementById('intensityVal').textContent = '100%';
        }

        function previewVintage(effect) {
            if (!originalImage) return;

            beforeEffectData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            pendingEffect = effect;
            pendingEffectType = 'vintage';

            applyVintageInternal(effect, 100);

            document.getElementById('intensitySection').style.display = 'block';
            document.getElementById('effectIntensity').value = 100;
            document.getElementById('intensityVal').textContent = '100%';
        }

        function updateIntensity() {
            if (!beforeEffectData || !pendingEffect) return;

            const intensity = parseInt(document.getElementById('effectIntensity').value);
            document.getElementById('intensityVal').textContent = intensity + '%';

            // Restore to state before this effect
            ctx.putImageData(beforeEffectData, 0, 0);

            // Apply effect at new intensity
            if (pendingEffectType === 'effect') {
                applyEffectInternal(pendingEffect, intensity);
            } else {
                applyVintageInternal(pendingEffect, intensity);
            }
        }

        function applyIntensity() {
            // Keep the effect, update working image, and save to history
            workingImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
            hideIntensitySection();
        }

        function cancelEffect() {
            if (beforeEffectData) {
                ctx.putImageData(beforeEffectData, 0, 0);
            }
            hideIntensitySection();
        }

        function hideIntensitySection() {
            document.getElementById('intensitySection').style.display = 'none';
            beforeEffectData = null;
            pendingEffect = null;
            pendingEffectType = null;
        }

        // Tab switching
        function switchTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            const tabBtn = document.getElementById(`tab${tab.charAt(0).toUpperCase() + tab.slice(1)}`);
            if (tabBtn) tabBtn.classList.add('active');

            ['panelAdjust', 'panelEffects', 'panelVintage', 'panelFrames'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.classList.add('hidden');
            });

            const panel = document.getElementById(`panel${tab.charAt(0).toUpperCase() + tab.slice(1)}`);
            if (panel) panel.classList.remove('hidden');
        }

        // Mobile Panel Functions
        function openMobilePanel(type) {
            activeMobilePanel = type;
            const overlay = document.getElementById('mobilePanelOverlay');
            const panel = document.getElementById('mobilePanel');
            const title = document.getElementById('mobilePanelTitle');
            const content = document.getElementById('mobilePanelContent');

            document.querySelectorAll('.mobile-nav-btn').forEach(btn => btn.classList.remove('active'));
            event.currentTarget.classList.add('active');

            const titles = {
                tools: 'üîß TOOLS',
                adjust: 'üéöÔ∏è ADJUSTMENTS',
                effects: '‚ú® EFFECTS',
                vintage: 'üì∑ VINTAGE',
                frames: 'üñºÔ∏è FRAMES'
            };
            title.textContent = titles[type] || type.toUpperCase();
            content.innerHTML = getMobilePanelContent(type);

            overlay.classList.add('active');
            panel.classList.add('active');
        }

        function closeMobilePanel() {
            document.getElementById('mobilePanelOverlay').classList.remove('active');
            document.getElementById('mobilePanel').classList.remove('active');
            document.querySelectorAll('.mobile-nav-btn').forEach(btn => btn.classList.remove('active'));
            activeMobilePanel = null;
        }

        function getMobilePanelContent(type) {
            switch (type) {
                case 'tools':
                    return `
                        <div class="space-y-4">
                            <!-- Auto Enhance -->
                            <div class="tool-section p-4">
                                <h3 class="vhs-font text-sm text-pink-400 mb-3">‚ú® MAGIC</h3>
                                <button onclick="autoEnhance(); closeMobilePanel();" class="btn-primary w-full">‚ö° AUTO ENHANCE</button>
                            </div>
                            
                            <div class="tool-section p-4">
                                <h3 class="vhs-font text-sm text-pink-400 mb-3">TRANSFORM</h3>
                                <div class="grid grid-cols-4 gap-3 mb-3">
                                    <button onclick="rotateImage(-90)" class="btn-icon">‚Ü∫</button>
                                    <button onclick="rotateImage(90)" class="btn-icon">‚Üª</button>
                                    <button onclick="flipImage('h')" class="btn-icon">‚áÜ</button>
                                    <button onclick="flipImage('v')" class="btn-icon">‚áÖ</button>
                                </div>
                                <button onclick="openCropModal(); closeMobilePanel();" class="btn-neon w-full">‚úÇÔ∏è CROP IMAGE</button>
                            </div>
                            
                            <!-- Stickers -->
                            <div class="tool-section p-4">
                                <h3 class="vhs-font text-sm text-pink-400 mb-3">üé® STICKERS</h3>
                                <p class="text-xs text-gray-400 mb-2">Tap to add, then drag to move ‚Ä¢ Use handles to rotate/resize</p>
                                <div class="grid grid-cols-4 gap-3 mb-3">
                                    <button onclick="addSticker('cassette')" class="btn-icon text-xl">üìº</button>
                                    <button onclick="addSticker('palm')" class="btn-icon text-xl">üå¥</button>
                                    <button onclick="addSticker('flamingo')" class="btn-icon text-xl">ü¶©</button>
                                    <button onclick="addSticker('sun')" class="btn-icon text-xl">üåÖ</button>
                                    <button onclick="addSticker('star')" class="btn-icon text-xl">‚≠ê</button>
                                    <button onclick="addSticker('heart')" class="btn-icon text-xl">üíú</button>
                                    <button onclick="addSticker('diamond')" class="btn-icon text-xl">üíé</button>
                                    <button onclick="addSticker('lightning')" class="btn-icon text-xl">‚ö°</button>
                                </div>
                                <div class="flex gap-2 mb-2">
                                    <button onclick="addGeometricShape()" class="btn-neon flex-1">‚óá SHAPE</button>
                                    <button onclick="document.getElementById('customStickerInput').click(); closeMobilePanel();" class="btn-neon flex-1">üìÅ CUSTOM</button>
                                </div>
                                <button onclick="flattenLayers(); closeMobilePanel();" class="btn-primary w-full">‚úì FLATTEN LAYERS</button>
                            </div>
                            
                            <!-- Gradient Overlays -->
                            <div class="tool-section p-4">
                                <h3 class="vhs-font text-sm text-pink-400 mb-3">üåà GRADIENT OVERLAYS</h3>
                                <div class="grid grid-cols-3 gap-2">
                                    <button onclick="applyGradientOverlay('sunset')" class="gradient-btn sunset-grad">SUNSET</button>
                                    <button onclick="applyGradientOverlay('vaporwave')" class="gradient-btn vapor-grad">VAPOR</button>
                                    <button onclick="applyGradientOverlay('neon')" class="gradient-btn neon-grad">NEON</button>
                                    <button onclick="applyGradientOverlay('miami')" class="gradient-btn miami-grad">MIAMI</button>
                                    <button onclick="applyGradientOverlay('cyber')" class="gradient-btn cyber-grad">CYBER</button>
                                    <button onclick="applyGradientOverlay('retro')" class="gradient-btn retro-grad">RETRO</button>
                                </div>
                            </div>
                            
                            <div class="tool-section p-4">
                                <h3 class="vhs-font text-sm text-pink-400 mb-3">DRAW</h3>
                                <div class="flex items-center gap-3 mb-3">
                                    <button onclick="setTool('brush'); updateMobileToolButtons()" class="btn-icon flex-1 ${currentTool === 'brush' ? 'active' : ''}" id="mobileBrushTool">üñåÔ∏è Brush</button>
                                    <button onclick="setTool('eraser'); updateMobileToolButtons()" class="btn-icon flex-1 ${currentTool === 'eraser' ? 'active' : ''}" id="mobileEraserTool">üßπ Eraser</button>
                                </div>
                                <div class="flex items-center gap-3 mb-3">
                                    <div class="color-picker-wrapper">
                                        <input type="color" id="mobileBrushColor" value="${document.getElementById('brushColor')?.value || '#ff2a6d'}" onchange="document.getElementById('brushColor').value = this.value">
                                    </div>
                                    <div class="flex-1 slider-wrapper">
                                        <label class="vhs-font text-xs text-gray-400">SIZE</label>
                                        <input type="range" id="mobileBrushSize" min="1" max="50" value="${document.getElementById('brushSize')?.value || 5}" onchange="document.getElementById('brushSize').value = this.value">
                                    </div>
                                </div>
                            </div>
                            <div class="tool-section p-4">
                                <h3 class="vhs-font text-sm text-pink-400 mb-3">ADD TEXT</h3>
                                <input type="text" id="mobileTextInput" placeholder="Enter text..." 
                                    class="w-full bg-black/50 border border-cyan-500/30 rounded px-3 py-3 text-base mb-3 focus:border-pink-500 focus:outline-none">
                                <div class="flex gap-2 mb-3">
                                    <select id="mobileTextFont" class="flex-1 bg-black/50 border border-cyan-500/30 rounded px-3 py-3 text-sm">
                                        <option value="VT323">VHS</option>
                                        <option value="Orbitron">RETRO</option>
                                        <option value="Press Start 2P">PIXEL</option>
                                    </select>
                                    <input type="number" id="mobileTextSize" value="32" min="8" max="120" 
                                        class="w-20 bg-black/50 border border-cyan-500/30 rounded px-3 py-3 text-sm">
                                </div>
                                <button onclick="addTextMobile()" class="btn-neon w-full">ADD TEXT</button>
                            </div>
                        </div>
                    `;

                case 'adjust':
                    return `
                        <div class="space-y-5">
                            ${['brightness', 'contrast', 'saturation', 'exposure', 'temperature', 'tint', 'vignette', 'blur', 'hue'].map(adj => `
                                <div class="slider-wrapper">
                                    <div class="flex justify-between mb-2">
                                        <label class="vhs-font text-sm text-pink-400">${adj.toUpperCase()}</label>
                                        <span class="vhs-font text-xs text-cyan-400" id="mobile${adj}Val">${document.getElementById(adj)?.value || 0}${adj === 'hue' ? '¬∞' : ''}</span>
                                    </div>
                                    <input type="range" id="mobile${adj}" 
                                        min="${adj === 'vignette' || adj === 'blur' ? 0 : adj === 'hue' ? 0 : -100}" 
                                        max="${adj === 'hue' ? 360 : adj === 'blur' ? 20 : 100}" 
                                        value="${document.getElementById(adj)?.value || 0}"
                                        step="${adj === 'blur' ? 0.5 : 1}"
                                        oninput="syncSlider('${adj}', this.value)">
                                </div>
                            `).join('')}
                        </div>
                    `;

                case 'effects':
                    return `
                        <div class="grid grid-cols-3 gap-3">
                            ${[
                            ['vhs', 'üìº', 'VHS'],
                            ['glitch', 'üëæ', 'GLITCH'],
                            ['scanlines', 'üì∫', 'SCAN'],
                            ['chromatic', 'üåà', 'RGB'],
                            ['pixelate', 'üéÆ', '8-BIT'],
                            ['neon', 'üíú', 'NEON'],
                            ['cyberpunk', 'üåÉ', 'CYBER'],
                            ['synthwave', 'üåÖ', 'SYNTH'],
                            ['vaporwave', 'üå¥', 'VAPOR'],
                            ['miami', 'üèñÔ∏è', 'MIAMI'],
                            ['tokyo', 'üóº', 'TOKYO'],
                            ['duotone', 'üé®', 'DUO']
                        ].map(([id, icon, label]) => `
                                <div class="effect-card" onclick="previewEffect('${id}'); closeMobilePanel();">
                                    <div class="text-2xl mb-1">${icon}</div>
                                    <div class="vhs-font text-xs">${label}</div>
                                </div>
                            `).join('')}
                        </div>
                    `;

                case 'vintage':
                    return `
                        <div class="grid grid-cols-3 gap-3">
                            ${[
                            ['sepia', 'üü§', 'SEPIA'],
                            ['faded', 'üå´Ô∏è', 'FADED'],
                            ['polaroid', 'üì∑', 'POLAROID'],
                            ['kodak', 'üéûÔ∏è', 'KODAK'],
                            ['grain', '‚ú®', 'GRAIN'],
                            ['dusty', 'üí®', 'DUSTY'],
                            ['lightleak', '‚òÄÔ∏è', 'LEAK'],
                            ['oldphoto', 'üñºÔ∏è', 'OLD'],
                            ['1970s', 'üï∫', '1970s'],
                            ['1980s', 'üíø', '1980s'],
                            ['1990s', 'üíæ', '1990s'],
                            ['daguerreotype', 'üèõÔ∏è', 'ANTIQUE']
                        ].map(([id, icon, label]) => `
                                <div class="effect-card" onclick="previewVintage('${id}'); closeMobilePanel();">
                                    <div class="text-2xl mb-1">${icon}</div>
                                    <div class="vhs-font text-xs">${label}</div>
                                </div>
                            `).join('')}
                        </div>
                    `;

                case 'frames':
                    return `
                        <div class="space-y-4">
                            <div class="grid grid-cols-2 gap-3">
                                <div class="effect-card" onclick="applyFrame('vhsFrame')">
                                    <div class="text-2xl mb-1">üìº</div>
                                    <div class="vhs-font text-xs">VHS FRAME</div>
                                </div>
                                <div class="effect-card" onclick="applyFrame('polaroidFrame')">
                                    <div class="text-2xl mb-1">üñºÔ∏è</div>
                                    <div class="vhs-font text-xs">POLAROID</div>
                                </div>
                                <div class="effect-card" onclick="applyFrame('neonBorder')">
                                    <div class="text-2xl mb-1">üí†</div>
                                    <div class="vhs-font text-xs">NEON</div>
                                </div>
                                <div class="effect-card" onclick="applyFrame('none')">
                                    <div class="text-2xl mb-1">‚ùå</div>
                                    <div class="vhs-font text-xs">NO FRAME</div>
                                </div>
                            </div>
                            <div class="tool-section p-4">
                                <h3 class="vhs-font text-sm text-pink-400 mb-3">OVERLAYS</h3>
                                <div class="space-y-2">
                                    <label class="checkbox-wrapper">
                                        <input type="checkbox" id="mobileOverlayTimestamp" ${overlays.timestamp ? 'checked' : ''} onchange="toggleOverlay('timestamp')">
                                        <span class="vhs-font text-sm">üìÖ TIMESTAMP</span>
                                    </label>
                                    <label class="checkbox-wrapper">
                                        <input type="checkbox" id="mobileOverlayRec" ${overlays.rec ? 'checked' : ''} onchange="toggleOverlay('rec')">
                                        <span class="vhs-font text-sm">üî¥ REC</span>
                                    </label>
                                    <label class="checkbox-wrapper">
                                        <input type="checkbox" id="mobileOverlayPlay" ${overlays.play ? 'checked' : ''} onchange="toggleOverlay('play')">
                                        <span class="vhs-font text-sm">‚ñ∂ PLAY</span>
                                    </label>
                                </div>
                            </div>
                        </div>
                    `;

                default:
                    return '';
            }
        }

        function syncSlider(name, value) {
            const desktopSlider = document.getElementById(name);
            if (desktopSlider) desktopSlider.value = value;

            const valDisplay = document.getElementById(`mobile${name}Val`);
            if (valDisplay) valDisplay.textContent = value + (name === 'hue' ? '¬∞' : '');

            updateAdjustments();
        }

        function updateMobileToolButtons() {
            const brushBtn = document.getElementById('mobileBrushTool');
            const eraserBtn = document.getElementById('mobileEraserTool');
            if (brushBtn) brushBtn.classList.toggle('active', currentTool === 'brush');
            if (eraserBtn) eraserBtn.classList.toggle('active', currentTool === 'eraser');
        }

        function addTextMobile() {
            const text = document.getElementById('mobileTextInput')?.value;
            const font = document.getElementById('mobileTextFont')?.value || 'VT323';
            const size = parseInt(document.getElementById('mobileTextSize')?.value) || 32;
            const color = document.getElementById('mobileBrushColor')?.value || '#ff2a6d';

            if (!text || !originalImage) return;

            // Measure text width
            ctx.font = `${size}px ${font}, monospace`;
            const textWidth = ctx.measureText(text).width;

            const layer = createLayer('text', text, {
                x: canvas.width / 2,
                y: canvas.height / 2,
                width: textWidth + 20,
                height: size + 20,
                color: color,
                font: font,
                fontSize: size
            });

            layers.push(layer);
            selectedLayer = layer;
            renderLayers();

            // Clear input
            document.getElementById('mobileTextInput').value = '';
            closeMobilePanel();
        }

        // Adjustments
        function updateAdjustments() {
            if (!originalImage) return;

            const getValue = (id) => parseFloat(document.getElementById(id)?.value || 0);

            const brightness = getValue('brightness');
            const contrast = getValue('contrast');
            const saturation = getValue('saturation');
            const exposure = getValue('exposure');
            const hue = getValue('hue');
            const blur = getValue('blur');
            const vignette = getValue('vignette');
            const temperature = getValue('temperature');
            const tint = getValue('tint');

            const updateVal = (id, val, suffix = '') => {
                const el = document.getElementById(id);
                if (el) el.textContent = val + suffix;
            };

            updateVal('brightnessVal', brightness);
            updateVal('contrastVal', contrast);
            updateVal('saturationVal', saturation);
            updateVal('exposureVal', exposure);
            updateVal('temperatureVal', temperature);
            updateVal('tintVal', tint);
            updateVal('vignetteVal', vignette);
            updateVal('blurVal', blur);
            updateVal('hueVal', hue, '¬∞');

            // Check if any adjustments are non-zero
            const hasAdjustments = brightness !== 0 || contrast !== 0 || saturation !== 0 ||
                exposure !== 0 || hue !== 0 || blur !== 0 ||
                vignette !== 0 || temperature !== 0 || tint !== 0;

            if (!hasAdjustments) {
                // No adjustments - just draw original
                ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
                workingImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                renderLayers();
                return;
            }

            const brightnessFilter = (brightness + 100) / 100;
            const contrastFilter = (contrast + 100) / 100;
            const saturationFilter = (saturation + 100) / 100;
            const exposureFilter = 1 + (exposure / 100);

            ctx.filter = `brightness(${brightnessFilter * exposureFilter}) contrast(${contrastFilter}) saturate(${saturationFilter}) hue-rotate(${hue}deg) blur(${blur}px)`;
            ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
            ctx.filter = 'none';

            if (temperature !== 0 || tint !== 0) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, Math.max(0, data[i] + temperature * 0.5));
                    data[i + 2] = Math.min(255, Math.max(0, data[i + 2] - temperature * 0.5));
                    data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + tint * 0.3));
                }
                ctx.putImageData(imageData, 0, 0);
            }

            if (vignette > 0) {
                const gradient = ctx.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, canvas.width * 0.2,
                    canvas.width / 2, canvas.height / 2, canvas.width * 0.7
                );
                gradient.addColorStop(0, 'rgba(0,0,0,0)');
                gradient.addColorStop(1, `rgba(0,0,0,${vignette / 100})`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Save working state after adjustments
            workingImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            // Render layers on top
            renderLayers();
        }

        function resetAdjustments() {
            ['brightness', 'contrast', 'saturation', 'exposure', 'temperature', 'tint', 'vignette', 'blur', 'hue'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.value = 0;
                const valEl = document.getElementById(id + 'Val');
                if (valEl) valEl.textContent = id === 'hue' ? '0¬∞' : '0';
            });
        }

        function resetImage() {
            if (originalImage) {
                // Reset to original image
                ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
                workingImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                // Clear layers
                layers = [];
                selectedLayer = null;

                // Reset adjustments
                resetAdjustments();

                // Reset frames and overlays
                currentFrame = 'none';
                overlays = { timestamp: false, rec: false, play: false };
                document.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);

                saveToHistory();
            }
        }

        // Effects with intensity
        function applyEffectInternal(effect, intensity) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const origData = beforeEffectData ? new Uint8ClampedArray(beforeEffectData.data) : null;
            const factor = intensity / 100;

            const effects = {
                vhs: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        const noise = (Math.random() - 0.5) * 25 * factor;
                        data[i] = Math.min(255, Math.max(0, data[i] + noise + 15 * factor));
                        data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise));
                        data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise + 25 * factor));
                    }
                },
                glitch: () => {
                    const temp = new Uint8ClampedArray(data);
                    for (let y = 0; y < canvas.height; y++) {
                        if (Math.random() > (1 - 0.08 * factor)) {
                            const offset = Math.floor((Math.random() - 0.5) * 60 * factor);
                            for (let x = 0; x < canvas.width; x++) {
                                const srcX = Math.min(canvas.width - 1, Math.max(0, x + offset));
                                const srcIdx = (y * canvas.width + srcX) * 4;
                                const dstIdx = (y * canvas.width + x) * 4;
                                data[dstIdx] = temp[srcIdx];
                                data[dstIdx + 1] = temp[srcIdx + 1];
                                data[dstIdx + 2] = temp[srcIdx + 2];
                            }
                        }
                    }
                },
                scanlines: () => {
                    for (let y = 0; y < canvas.height; y += 2) {
                        for (let x = 0; x < canvas.width; x++) {
                            const idx = (y * canvas.width + x) * 4;
                            const darkFactor = 1 - (0.3 * factor);
                            data[idx] *= darkFactor;
                            data[idx + 1] *= darkFactor;
                            data[idx + 2] *= darkFactor;
                        }
                    }
                },
                chromatic: () => {
                    const temp = new Uint8ClampedArray(data);
                    const shift = Math.round(6 * factor);
                    for (let y = 0; y < canvas.height; y++) {
                        for (let x = 0; x < canvas.width; x++) {
                            const idx = (y * canvas.width + x) * 4;
                            const rIdx = (y * canvas.width + Math.min(canvas.width - 1, x + shift)) * 4;
                            const bIdx = (y * canvas.width + Math.max(0, x - shift)) * 4;
                            data[idx] = temp[rIdx];
                            data[idx + 2] = temp[bIdx];
                        }
                    }
                },
                pixelate: () => {
                    const size = Math.max(1, Math.round(6 * factor));
                    for (let y = 0; y < canvas.height; y += size) {
                        for (let x = 0; x < canvas.width; x += size) {
                            const idx = (y * canvas.width + x) * 4;
                            const r = data[idx], g = data[idx + 1], b = data[idx + 2];
                            for (let py = 0; py < size && y + py < canvas.height; py++) {
                                for (let px = 0; px < size && x + px < canvas.width; px++) {
                                    const pIdx = ((y + py) * canvas.width + (x + px)) * 4;
                                    data[pIdx] = r; data[pIdx + 1] = g; data[pIdx + 2] = b;
                                }
                            }
                        }
                    }
                },
                neon: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        if ((data[i] + data[i + 1] + data[i + 2]) / 3 > 100) {
                            data[i] = Math.min(255, data[i] + (data[i] * 0.4 * factor));
                            data[i + 2] = Math.min(255, data[i + 2] + (data[i + 2] * 0.5 * factor));
                        }
                        data[i + 1] *= (1 - 0.4 * factor);
                    }
                },
                cyberpunk: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * (1 - 0.2 * factor) + 40 * factor);
                        data[i + 1] *= (1 - 0.1 * factor);
                        data[i + 2] = Math.min(255, data[i + 2] * (1 + 0.3 * factor));
                    }
                },
                synthwave: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        const y = Math.floor((i / 4) / canvas.width) / canvas.height;
                        data[i] = Math.min(255, data[i] * (1 + (0.2 + y * 0.3) * factor));
                        data[i + 1] *= (1 - (0.4 - y * 0.2) * factor);
                        data[i + 2] = Math.min(255, data[i + 2] * (1 + (0.4 - y * 0.3) * factor));
                    }
                },
                vaporwave: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * (1 - 0.1 * factor) + 60 * factor);
                        data[i + 1] = Math.min(255, data[i + 1] * (1 + 0.1 * factor) + 40 * factor);
                        data[i + 2] = Math.min(255, data[i + 2] * (1 + 0.2 * factor) + 70 * factor);
                    }
                },
                miami: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * (1 + 0.3 * factor) + 30 * factor);
                        data[i + 1] *= (1 - 0.15 * factor);
                        data[i + 2] = Math.min(255, data[i + 2] * (1 + 0.2 * factor) + 50 * factor);
                    }
                },
                tokyo: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * (1 + 0.1 * factor) + 20 * factor);
                        data[i + 1] *= (1 - 0.3 * factor);
                        data[i + 2] = Math.min(255, data[i + 2] * (1 + 0.5 * factor));
                    }
                },
                duotone: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        data[i] = data[i] + (gray * 1.5 - data[i]) * factor;
                        data[i + 1] = data[i + 1] + (gray * 0.2 - data[i + 1]) * factor;
                        data[i + 2] = data[i + 2] + (gray * 1.8 - data[i + 2]) * factor;
                    }
                }
            };

            if (effects[effect]) effects[effect]();
            ctx.putImageData(imageData, 0, 0);
            renderOverlays();
        }

        function applyVintageInternal(effect, intensity) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const factor = intensity / 100;

            const effects = {
                sepia: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        const newR = r * 0.393 + g * 0.769 + b * 0.189;
                        const newG = r * 0.349 + g * 0.686 + b * 0.168;
                        const newB = r * 0.272 + g * 0.534 + b * 0.131;
                        data[i] = r + (newR - r) * factor;
                        data[i + 1] = g + (newG - g) * factor;
                        data[i + 2] = b + (newB - b) * factor;
                    }
                },
                faded: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * (1 - 0.1 * factor) + 25 * factor);
                        data[i + 1] = Math.min(255, data[i + 1] * (1 - 0.15 * factor) + 20 * factor);
                        data[i + 2] = Math.min(255, data[i + 2] * (1 - 0.2 * factor) + 30 * factor);
                    }
                },
                polaroid: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * (1 + 0.1 * factor) + 10 * factor);
                        data[i + 1] = Math.min(255, data[i + 1] * (1 + 0.05 * factor) + 10 * factor);
                        data[i + 2] = data[i + 2] * (1 - 0.1 * factor) + 20 * factor;
                    }
                },
                kodak: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * (1 + 0.15 * factor) + 15 * factor);
                        data[i + 1] = Math.min(255, data[i + 1] * (1 + 0.05 * factor) + 5 * factor);
                        data[i + 2] = data[i + 2] * (1 - 0.15 * factor);
                    }
                },
                grain: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        const grain = (Math.random() - 0.5) * 40 * factor;
                        data[i] = Math.min(255, Math.max(0, data[i] + grain));
                        data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + grain));
                        data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + grain));
                    }
                },
                dusty: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        if (Math.random() > (1 - 0.005 * factor)) data[i] = data[i + 1] = data[i + 2] = 255;
                        const grain = (Math.random() - 0.5) * 20 * factor;
                        data[i] = Math.min(255, Math.max(0, data[i] + grain + 10 * factor));
                        data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + grain + 5 * factor));
                        data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + grain));
                    }
                },
                lightleak: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        const x = (i / 4) % canvas.width;
                        const y = Math.floor((i / 4) / canvas.width);
                        const dist = Math.sqrt(Math.pow(x - canvas.width * 0.8, 2) + Math.pow(y - canvas.height * 0.2, 2));
                        const maxDist = Math.sqrt(Math.pow(canvas.width, 2) + Math.pow(canvas.height, 2)) * 0.5;
                        const leakIntensity = Math.max(0, 1 - dist / maxDist) * 100 * factor;
                        data[i] = Math.min(255, data[i] + leakIntensity * 1.5);
                        data[i + 1] = Math.min(255, data[i + 1] + leakIntensity * 0.8);
                    }
                },
                oldphoto: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        const grain = (Math.random() - 0.5) * 30 * factor;
                        data[i] = data[i] + (gray * 1.1 + 30 + grain - data[i]) * factor;
                        data[i + 1] = data[i + 1] + (gray * 0.9 + 15 + grain - data[i + 1]) * factor;
                        data[i + 2] = data[i + 2] + (gray * 0.7 + grain - data[i + 2]) * factor;
                    }
                },
                '1970s': () => {
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * (1 + 0.1 * factor) + 20 * factor);
                        data[i + 1] = Math.min(255, data[i + 1] * (1 - 0.05 * factor) + 10 * factor);
                        data[i + 2] = data[i + 2] * (1 - 0.2 * factor);
                    }
                },
                '1980s': () => {
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * (1 + 0.2 * factor) + 15 * factor);
                        data[i + 1] = data[i + 1] * (1 - 0.15 * factor);
                        data[i + 2] = Math.min(255, data[i + 2] * (1 + 0.3 * factor) + 20 * factor);
                    }
                },
                '1990s': () => {
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * (1 + 0.05 * factor) + 5 * factor);
                        data[i + 1] = Math.min(255, data[i + 1] * (1 + 0.1 * factor));
                        data[i + 2] = Math.min(255, data[i + 2] * (1 + 0.15 * factor) + 10 * factor);
                    }
                },
                daguerreotype: () => {
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                        const contrast = ((gray - 128) * 1.3) + 128;
                        data[i] = data[i] + (contrast + 20 - data[i]) * factor;
                        data[i + 1] = data[i + 1] + (contrast + 10 - data[i + 1]) * factor;
                        data[i + 2] = data[i + 2] + (contrast - data[i + 2]) * factor;
                    }
                }
            };

            if (effects[effect]) effects[effect]();
            ctx.putImageData(imageData, 0, 0);
            renderOverlays();
        }

        // Legacy effect functions for frames panel
        function applyEffect(effect) {
            if (!originalImage) return;
            beforeEffectData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            applyEffectInternal(effect, 100);
            saveToHistory();
        }

        function applyVintage(effect) {
            if (!originalImage) return;
            beforeEffectData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            applyVintageInternal(effect, 100);
            saveToHistory();
        }

        // Frames & Overlays
        function applyFrame(frame) {
            currentFrame = frame;
            updateAdjustments();
            saveToHistory();
        }

        function toggleOverlay(overlay) {
            overlays[overlay] = !overlays[overlay];
            updateAdjustments();
        }

        function renderOverlays() {
            if (currentFrame === 'vhsFrame') {
                const topGrad = ctx.createLinearGradient(0, 0, 0, 50);
                topGrad.addColorStop(0, 'rgba(0,0,0,0.7)');
                topGrad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = topGrad;
                ctx.fillRect(0, 0, canvas.width, 50);

                const bottomGrad = ctx.createLinearGradient(0, canvas.height - 50, 0, canvas.height);
                bottomGrad.addColorStop(0, 'rgba(0,0,0,0)');
                bottomGrad.addColorStop(1, 'rgba(0,0,0,0.7)');
                ctx.fillStyle = bottomGrad;
                ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
            }

            if (currentFrame === 'polaroidFrame') {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 15;
                ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
            }

            if (currentFrame === 'neonBorder') {
                ctx.strokeStyle = '#ff2a6d';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#ff2a6d';
                ctx.shadowBlur = 15;
                ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);
                ctx.strokeStyle = '#05d9e8';
                ctx.strokeRect(15, 15, canvas.width - 30, canvas.height - 30);
                ctx.shadowBlur = 0;
            }

            if (overlays.timestamp) {
                const now = new Date();
                const year = 1985 + Math.floor(Math.random() * 10);
                ctx.fillStyle = '#ffcc00';
                ctx.font = 'bold 20px VT323, monospace';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 4;
                ctx.fillText(`${now.getMonth() + 1}/${now.getDate()}/${year}`, canvas.width - 120, canvas.height - 15);
                ctx.shadowBlur = 0;
            }

            if (overlays.rec) {
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(25, 25, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px VT323, monospace';
                ctx.fillText('REC', 38, 30);
            }

            if (overlays.play) {
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 18px VT323, monospace';
                ctx.fillText('‚ñ∂ PLAY', 15, canvas.height - 15);
            }
        }

        // Crop functions
        function openCropModal() {
            if (!originalImage) return;

            const modal = document.getElementById('cropModal');
            const cropCanvas = document.getElementById('cropCanvas');
            const cropCtx = cropCanvas.getContext('2d');

            // Copy current canvas to crop canvas
            cropCanvas.width = canvas.width;
            cropCanvas.height = canvas.height;
            cropCtx.drawImage(canvas, 0, 0);

            // Initialize crop box
            cropBox = {
                x: canvas.width * 0.1,
                y: canvas.height * 0.1,
                width: canvas.width * 0.8,
                height: canvas.height * 0.8
            };

            updateCropBox();
            modal.classList.add('active');

            // Setup crop events
            setupCropEvents();
        }

        function closeCropModal() {
            document.getElementById('cropModal').classList.remove('active');
        }

        function setAspectRatio(ratio) {
            cropAspectRatio = ratio;

            // Update button states
            document.querySelectorAll('.aspect-btn').forEach(btn => btn.classList.remove('active'));
            const btnId = 'aspect' + ratio.replace(':', '_').replace('free', 'Free');
            const btn = document.getElementById(btnId);
            if (btn) btn.classList.add('active');

            // Adjust crop box to match ratio
            if (ratio !== 'free') {
                const [w, h] = ratio.split(':').map(Number);
                const aspectRatio = w / h;

                const maxWidth = canvas.width * 0.8;
                const maxHeight = canvas.height * 0.8;

                if (maxWidth / aspectRatio <= maxHeight) {
                    cropBox.width = maxWidth;
                    cropBox.height = maxWidth / aspectRatio;
                } else {
                    cropBox.height = maxHeight;
                    cropBox.width = maxHeight * aspectRatio;
                }

                cropBox.x = (canvas.width - cropBox.width) / 2;
                cropBox.y = (canvas.height - cropBox.height) / 2;

                updateCropBox();
            }
        }

        function updateCropBox() {
            const cropBoxEl = document.getElementById('cropBox');
            const cropCanvas = document.getElementById('cropCanvas');
            const rect = cropCanvas.getBoundingClientRect();
            const scaleX = rect.width / canvas.width;
            const scaleY = rect.height / canvas.height;

            cropBoxEl.style.left = (cropBox.x * scaleX) + 'px';
            cropBoxEl.style.top = (cropBox.y * scaleY) + 'px';
            cropBoxEl.style.width = (cropBox.width * scaleX) + 'px';
            cropBoxEl.style.height = (cropBox.height * scaleY) + 'px';
        }

        function setupCropEvents() {
            const cropBoxEl = document.getElementById('cropBox');
            const cropCanvas = document.getElementById('cropCanvas');

            cropBoxEl.addEventListener('mousedown', startCropDrag);
            cropBoxEl.addEventListener('touchstart', startCropDrag, { passive: false });

            document.querySelectorAll('.crop-handle').forEach(handle => {
                handle.addEventListener('mousedown', startCropResize);
                handle.addEventListener('touchstart', startCropResize, { passive: false });
            });
        }

        function startCropDrag(e) {
            if (e.target.classList.contains('crop-handle')) return;
            e.preventDefault();

            isDraggingCrop = true;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            cropStartPos = { x: clientX - cropBox.x, y: clientY - cropBox.y };

            document.addEventListener('mousemove', dragCrop);
            document.addEventListener('mouseup', stopCropDrag);
            document.addEventListener('touchmove', dragCrop, { passive: false });
            document.addEventListener('touchend', stopCropDrag);
        }

        function dragCrop(e) {
            if (!isDraggingCrop) return;
            e.preventDefault();

            const cropCanvas = document.getElementById('cropCanvas');
            const rect = cropCanvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            cropBox.x = Math.max(0, Math.min(canvas.width - cropBox.width, (clientX - rect.left) * scaleX - cropStartPos.x));
            cropBox.y = Math.max(0, Math.min(canvas.height - cropBox.height, (clientY - rect.top) * scaleY - cropStartPos.y));

            updateCropBox();
        }

        function stopCropDrag() {
            isDraggingCrop = false;
            document.removeEventListener('mousemove', dragCrop);
            document.removeEventListener('mouseup', stopCropDrag);
            document.removeEventListener('touchmove', dragCrop);
            document.removeEventListener('touchend', stopCropDrag);
        }

        function startCropResize(e) {
            e.preventDefault();
            e.stopPropagation();

            isResizingCrop = true;
            resizeHandle = e.target.dataset.handle;

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            cropStartPos = { x: clientX, y: clientY, ...cropBox };

            document.addEventListener('mousemove', resizeCrop);
            document.addEventListener('mouseup', stopCropResize);
            document.addEventListener('touchmove', resizeCrop, { passive: false });
            document.addEventListener('touchend', stopCropResize);
        }

        function resizeCrop(e) {
            if (!isResizingCrop) return;
            e.preventDefault();

            const cropCanvas = document.getElementById('cropCanvas');
            const rect = cropCanvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const dx = (clientX - cropStartPos.x) * scaleX;
            const dy = (clientY - cropStartPos.y) * scaleY;

            const minSize = 50;

            if (resizeHandle.includes('e')) {
                cropBox.width = Math.max(minSize, Math.min(canvas.width - cropBox.x, cropStartPos.width + dx));
            }
            if (resizeHandle.includes('w')) {
                const newWidth = Math.max(minSize, cropStartPos.width - dx);
                const newX = Math.max(0, cropStartPos.x + cropStartPos.width - newWidth);
                cropBox.width = cropStartPos.x + cropStartPos.width - newX;
                cropBox.x = newX;
            }
            if (resizeHandle.includes('s')) {
                cropBox.height = Math.max(minSize, Math.min(canvas.height - cropBox.y, cropStartPos.height + dy));
            }
            if (resizeHandle.includes('n')) {
                const newHeight = Math.max(minSize, cropStartPos.height - dy);
                const newY = Math.max(0, cropStartPos.y + cropStartPos.height - newHeight);
                cropBox.height = cropStartPos.y + cropStartPos.height - newY;
                cropBox.y = newY;
            }

            // Maintain aspect ratio if set
            if (cropAspectRatio !== 'free') {
                const [w, h] = cropAspectRatio.split(':').map(Number);
                const aspectRatio = w / h;

                if (resizeHandle.includes('e') || resizeHandle.includes('w')) {
                    cropBox.height = cropBox.width / aspectRatio;
                } else {
                    cropBox.width = cropBox.height * aspectRatio;
                }
            }

            updateCropBox();
        }

        function stopCropResize() {
            isResizingCrop = false;
            resizeHandle = null;
            document.removeEventListener('mousemove', resizeCrop);
            document.removeEventListener('mouseup', stopCropResize);
            document.removeEventListener('touchmove', resizeCrop);
            document.removeEventListener('touchend', stopCropResize);
        }

        function applyCrop() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            tempCanvas.width = cropBox.width;
            tempCanvas.height = cropBox.height;

            tempCtx.drawImage(canvas,
                cropBox.x, cropBox.y, cropBox.width, cropBox.height,
                0, 0, cropBox.width, cropBox.height
            );

            canvas.width = cropBox.width;
            canvas.height = cropBox.height;
            ctx.drawImage(tempCanvas, 0, 0);

            // Update original image
            const newImg = new Image();
            newImg.onload = () => {
                originalImage = newImg;
                originalCanvas.width = canvas.width;
                originalCanvas.height = canvas.height;
                originalCtx.drawImage(newImg, 0, 0);
            };
            newImg.src = canvas.toDataURL();

            document.getElementById('imageInfo').textContent = `${Math.round(cropBox.width)} √ó ${Math.round(cropBox.height)} px`;

            saveToHistory();
            closeCropModal();
        }

        // Transform functions
        function rotateImage(degrees) {
            if (!originalImage) return;

            const temp = document.createElement('canvas');
            const tempCtx = temp.getContext('2d');

            if (Math.abs(degrees) === 90) {
                temp.width = canvas.height;
                temp.height = canvas.width;
            } else {
                temp.width = canvas.width;
                temp.height = canvas.height;
            }

            tempCtx.translate(temp.width / 2, temp.height / 2);
            tempCtx.rotate(degrees * Math.PI / 180);
            tempCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);

            canvas.width = temp.width;
            canvas.height = temp.height;
            ctx.drawImage(temp, 0, 0);

            const newImg = new Image();
            newImg.onload = () => {
                originalImage = newImg;
                originalCanvas.width = canvas.width;
                originalCanvas.height = canvas.height;
                originalCtx.drawImage(newImg, 0, 0);
            };
            newImg.src = canvas.toDataURL();

            document.getElementById('imageInfo').textContent = `${Math.round(canvas.width)} √ó ${Math.round(canvas.height)} px`;
            saveToHistory();
        }

        function flipImage(direction) {
            if (!originalImage) return;

            const temp = document.createElement('canvas');
            const tempCtx = temp.getContext('2d');
            temp.width = canvas.width;
            temp.height = canvas.height;

            if (direction === 'h') {
                tempCtx.translate(canvas.width, 0);
                tempCtx.scale(-1, 1);
            } else {
                tempCtx.translate(0, canvas.height);
                tempCtx.scale(1, -1);
            }

            tempCtx.drawImage(canvas, 0, 0);
            ctx.drawImage(temp, 0, 0);

            const newImg = new Image();
            newImg.onload = () => {
                originalImage = newImg;
                originalCanvas.width = canvas.width;
                originalCanvas.height = canvas.height;
                originalCtx.drawImage(newImg, 0, 0);
            };
            newImg.src = canvas.toDataURL();

            saveToHistory();
        }

        // Zoom
        function zoomCanvas(delta) {
            zoom = Math.max(0.25, Math.min(3, zoom + delta));
            canvas.style.transform = `scale(${zoom})`;
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
        }

        function resetZoom() {
            zoom = 1;
            canvas.style.transform = 'scale(1)';
            document.getElementById('zoomLevel').textContent = '100%';
        }

        // Drawing tools
        function setTool(tool) {
            currentTool = currentTool === tool ? null : tool;
            const brushBtn = document.getElementById('brushTool');
            const eraserBtn = document.getElementById('eraserTool');
            if (brushBtn) brushBtn.classList.toggle('active', currentTool === 'brush');
            if (eraserBtn) eraserBtn.classList.toggle('active', currentTool === 'eraser');
            canvas.style.cursor = currentTool ? 'crosshair' : 'default';
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', stopDrawing);

        function handleTouchStart(e) {
            if (!currentTool) return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            isDrawing = true;
            lastX = (touch.clientX - rect.left) * (canvas.width / rect.width);
            lastY = (touch.clientY - rect.top) * (canvas.height / rect.height);
        }

        function handleTouchMove(e) {
            if (!isDrawing || !currentTool) return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = (touch.clientX - rect.left) * (canvas.width / rect.width);
            const y = (touch.clientY - rect.top) * (canvas.height / rect.height);

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.strokeStyle = currentTool === 'eraser' ? '#ffffff' : (document.getElementById('brushColor')?.value || '#ff2a6d');
            ctx.lineWidth = document.getElementById('brushSize')?.value || 5;
            ctx.lineCap = 'round';
            ctx.stroke();

            lastX = x;
            lastY = y;
        }

        function startDrawing(e) {
            if (!currentTool) return;
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastX = (e.clientX - rect.left) * (canvas.width / rect.width);
            lastY = (e.clientY - rect.top) * (canvas.height / rect.height);
        }

        function draw(e) {
            if (!isDrawing || !currentTool) return;

            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.strokeStyle = currentTool === 'eraser' ? '#ffffff' : (document.getElementById('brushColor')?.value || '#ff2a6d');
            ctx.lineWidth = document.getElementById('brushSize')?.value || 5;
            ctx.lineCap = 'round';
            ctx.stroke();

            lastX = x;
            lastY = y;
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                saveToHistory();
            }
        }

        // Text tool - now uses layer system
        function addText() {
            if (!originalImage) return;

            const text = document.getElementById('textInput')?.value;
            if (!text) return;

            const font = document.getElementById('textFont')?.value || 'VT323';
            const size = parseInt(document.getElementById('textSize')?.value) || 32;
            const color = document.getElementById('brushColor')?.value || '#ff2a6d';

            // Measure text width
            ctx.font = `${size}px ${font}, monospace`;
            const textWidth = ctx.measureText(text).width;

            const layer = createLayer('text', text, {
                x: canvas.width / 2,
                y: canvas.height / 2,
                width: textWidth + 20,
                height: size + 20,
                color: color,
                font: font,
                fontSize: size
            });

            layers.push(layer);
            selectedLayer = layer;
            renderLayers();

            // Clear input
            document.getElementById('textInput').value = '';
        }

        // Custom sticker upload handler
        function handleCustomStickerUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                addCustomSticker(event.target.result);
            };
            reader.readAsDataURL(file);
            e.target.value = ''; // Reset for next upload
        }

        // Download
        function downloadImage(format = 'png') {
            if (!originalImage) return;

            const link = document.createElement('a');
            const timestamp = new Date().getTime();
            link.download = `neon_memories_${timestamp}.${format}`;
            link.href = canvas.toDataURL(`image/${format === 'jpg' ? 'jpeg' : 'png'}`, 0.9);
            link.click();
        }

        // Handle resize
        window.addEventListener('resize', () => {
            if (activeMobilePanel && window.innerWidth >= 1024) {
                closeMobilePanel();
            }
            updateCropBox();
        });

        // Auto Enhance - One click image improvement
        function autoEnhance() {
            if (!originalImage) return;

            // Add visual feedback
            canvas.classList.add('enhancing');
            setTimeout(() => canvas.classList.remove('enhancing'), 1000);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Calculate image statistics
            let totalR = 0, totalG = 0, totalB = 0;
            let minBrightness = 255, maxBrightness = 0;

            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                minBrightness = Math.min(minBrightness, brightness);
                maxBrightness = Math.max(maxBrightness, brightness);
                totalR += data[i];
                totalG += data[i + 1];
                totalB += data[i + 2];
            }

            const pixelCount = data.length / 4;
            const avgR = totalR / pixelCount;
            const avgG = totalG / pixelCount;
            const avgB = totalB / pixelCount;
            const avgBrightness = (avgR + avgG + avgB) / 3;

            // Auto levels - stretch histogram
            const range = maxBrightness - minBrightness;
            const scale = range > 0 ? 255 / range : 1;

            // Calculate saturation boost based on current saturation
            const avgSaturation = Math.max(avgR, avgG, avgB) - Math.min(avgR, avgG, avgB);
            const satBoost = avgSaturation < 50 ? 1.3 : (avgSaturation < 100 ? 1.15 : 1.05);

            // Apply enhancements
            for (let i = 0; i < data.length; i += 4) {
                // Auto levels
                let r = (data[i] - minBrightness) * scale;
                let g = (data[i + 1] - minBrightness) * scale;
                let b = (data[i + 2] - minBrightness) * scale;

                // Boost contrast slightly
                r = ((r / 255 - 0.5) * 1.1 + 0.5) * 255;
                g = ((g / 255 - 0.5) * 1.1 + 0.5) * 255;
                b = ((b / 255 - 0.5) * 1.1 + 0.5) * 255;

                // Boost saturation
                const gray = (r + g + b) / 3;
                r = gray + (r - gray) * satBoost;
                g = gray + (g - gray) * satBoost;
                b = gray + (b - gray) * satBoost;

                // Slight warmth for retro feel
                r = r * 1.02;
                b = b * 0.98;

                // Add subtle vignette
                const x = (i / 4) % canvas.width;
                const y = Math.floor((i / 4) / canvas.width);
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const dist = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                const maxDist = Math.sqrt(Math.pow(centerX, 2) + Math.pow(centerY, 2));
                const vignette = 1 - (dist / maxDist) * 0.15;

                data[i] = Math.min(255, Math.max(0, r * vignette));
                data[i + 1] = Math.min(255, Math.max(0, g * vignette));
                data[i + 2] = Math.min(255, Math.max(0, b * vignette));
            }

            ctx.putImageData(imageData, 0, 0);
            saveToHistory();
        }

        // Layer-based Stickers and Text System
        const stickerEmojis = {
            cassette: 'üìº',
            palm: 'üå¥',
            flamingo: 'ü¶©',
            sun: 'üåÖ',
            star: '‚≠ê',
            heart: 'üíú',
            diamond: 'üíé',
            lightning: '‚ö°'
        };

        // Create a layer object
        function createLayer(type, content, options = {}) {
            return {
                id: Date.now() + Math.random(),
                type: type, // 'sticker', 'text', 'shape', 'custom'
                content: content,
                x: options.x || canvas.width / 2,
                y: options.y || canvas.height / 2,
                width: options.width || 80,
                height: options.height || 80,
                rotation: options.rotation || 0,
                scale: options.scale || 1,
                color: options.color || '#ff2a6d',
                font: options.font || 'VT323',
                fontSize: options.fontSize || 32,
                image: options.image || null
            };
        }

        function addSticker(type) {
            if (!originalImage) return;

            const emoji = stickerEmojis[type] || '‚≠ê';
            const size = Math.min(canvas.width, canvas.height) * 0.15;

            const layer = createLayer('sticker', emoji, {
                x: canvas.width / 2,
                y: canvas.height / 2,
                width: size,
                height: size,
                fontSize: size
            });

            layers.push(layer);
            selectedLayer = layer;
            renderLayers();
        }

        // Add custom sticker from uploaded image
        function addCustomSticker(imageSrc) {
            if (!originalImage) return;

            const img = new Image();
            img.onload = () => {
                const maxSize = Math.min(canvas.width, canvas.height) * 0.3;
                let width = img.width;
                let height = img.height;

                if (width > maxSize || height > maxSize) {
                    const ratio = Math.min(maxSize / width, maxSize / height);
                    width *= ratio;
                    height *= ratio;
                }

                const layer = createLayer('custom', 'custom', {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    width: width,
                    height: height,
                    image: img
                });

                layers.push(layer);
                selectedLayer = layer;
                renderLayers();
            };
            img.src = imageSrc;
        }

        // Geometric Shapes as layers
        function addGeometricShape() {
            if (!originalImage) return;

            const shapes = ['triangle', 'diamond', 'hexagon', 'circle', 'lines'];
            const shape = shapes[Math.floor(Math.random() * shapes.length)];
            const size = Math.min(canvas.width, canvas.height) * 0.25;

            const layer = createLayer('shape', shape, {
                x: canvas.width / 2,
                y: canvas.height / 2,
                width: size,
                height: size
            });

            layers.push(layer);
            selectedLayer = layer;
            renderLayers();
        }

        // Render all layers on top of the canvas
        function renderLayers() {
            // First restore the base image
            if (workingImageData) {
                ctx.putImageData(workingImageData, 0, 0);
            }

            // Render overlays first
            renderOverlays();

            // Then render each layer
            layers.forEach(layer => {
                ctx.save();
                ctx.translate(layer.x, layer.y);
                ctx.rotate(layer.rotation * Math.PI / 180);
                ctx.scale(layer.scale, layer.scale);

                if (layer.type === 'sticker') {
                    ctx.font = `${layer.fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = '#ff2a6d';
                    ctx.shadowBlur = 10;
                    ctx.fillText(layer.content, 0, 0);
                    ctx.shadowBlur = 0;
                } else if (layer.type === 'text') {
                    ctx.font = `${layer.fontSize}px ${layer.font}, monospace`;
                    ctx.fillStyle = layer.color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = layer.color;
                    ctx.shadowBlur = 10;
                    ctx.fillText(layer.content, 0, 0);
                    ctx.shadowBlur = 0;
                } else if (layer.type === 'custom' && layer.image) {
                    ctx.drawImage(layer.image, -layer.width / 2, -layer.height / 2, layer.width, layer.height);
                } else if (layer.type === 'shape') {
                    drawShape(layer);
                }

                ctx.restore();

                // Draw selection handles if selected
                if (layer === selectedLayer) {
                    drawSelectionHandles(layer);
                }
            });
        }

        function drawShape(layer) {
            const size = layer.width;

            ctx.strokeStyle = '#ff2a6d';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ff2a6d';
            ctx.shadowBlur = 15;

            ctx.beginPath();

            switch (layer.content) {
                case 'triangle':
                    ctx.moveTo(0, -size / 2);
                    ctx.lineTo(size / 2, size / 2);
                    ctx.lineTo(-size / 2, size / 2);
                    ctx.closePath();
                    break;
                case 'diamond':
                    ctx.moveTo(0, -size / 2);
                    ctx.lineTo(size / 2, 0);
                    ctx.lineTo(0, size / 2);
                    ctx.lineTo(-size / 2, 0);
                    ctx.closePath();
                    break;
                case 'hexagon':
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i - Math.PI / 2;
                        const x = size / 2 * Math.cos(angle);
                        const y = size / 2 * Math.sin(angle);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    break;
                case 'circle':
                    ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                    break;
                case 'lines':
                    for (let i = -3; i <= 3; i++) {
                        ctx.moveTo(-size / 2, i * 12);
                        ctx.lineTo(size / 2, i * 12);
                    }
                    break;
            }

            ctx.stroke();

            // Cyan offset for 3D effect
            ctx.strokeStyle = '#05d9e8';
            ctx.shadowColor = '#05d9e8';
            ctx.translate(3, 3);
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        function drawSelectionHandles(layer) {
            const halfW = (layer.width * layer.scale) / 2 + 10;
            const halfH = (layer.height * layer.scale) / 2 + 10;

            ctx.save();
            ctx.translate(layer.x, layer.y);
            ctx.rotate(layer.rotation * Math.PI / 180);

            // Selection box
            ctx.strokeStyle = '#05d9e8';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(-halfW, -halfH, halfW * 2, halfH * 2);
            ctx.setLineDash([]);

            // Corner handles (for resize)
            const handleSize = 10;
            ctx.fillStyle = '#ff2a6d';
            [[-halfW, -halfH], [halfW, -halfH], [-halfW, halfH], [halfW, halfH]].forEach(([x, y]) => {
                ctx.fillRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
            });

            // Rotation handle (top center)
            ctx.fillStyle = '#05d9e8';
            ctx.beginPath();
            ctx.arc(0, -halfH - 20, 8, 0, Math.PI * 2);
            ctx.fill();

            // Line to rotation handle
            ctx.strokeStyle = '#05d9e8';
            ctx.beginPath();
            ctx.moveTo(0, -halfH);
            ctx.lineTo(0, -halfH - 12);
            ctx.stroke();

            // Delete button (top right)
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(halfW + 15, -halfH - 15, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('√ó', halfW + 15, -halfH - 15);

            ctx.restore();
        }

        // Layer interaction handlers
        function getLayerAtPoint(x, y) {
            // Check layers in reverse order (top first)
            for (let i = layers.length - 1; i >= 0; i--) {
                const layer = layers[i];
                const dx = x - layer.x;
                const dy = y - layer.y;

                // Rotate point back to check bounds
                const cos = Math.cos(-layer.rotation * Math.PI / 180);
                const sin = Math.sin(-layer.rotation * Math.PI / 180);
                const rx = dx * cos - dy * sin;
                const ry = dx * sin + dy * cos;

                const halfW = (layer.width * layer.scale) / 2 + 15;
                const halfH = (layer.height * layer.scale) / 2 + 15;

                if (Math.abs(rx) <= halfW && Math.abs(ry) <= halfH) {
                    return layer;
                }
            }
            return null;
        }

        function getHandleAtPoint(x, y, layer) {
            if (!layer) return null;

            const dx = x - layer.x;
            const dy = y - layer.y;
            const cos = Math.cos(-layer.rotation * Math.PI / 180);
            const sin = Math.sin(-layer.rotation * Math.PI / 180);
            const rx = dx * cos - dy * sin;
            const ry = dx * sin + dy * cos;

            const halfW = (layer.width * layer.scale) / 2 + 10;
            const halfH = (layer.height * layer.scale) / 2 + 10;

            // Check rotation handle
            if (Math.abs(rx) < 15 && Math.abs(ry + halfH + 20) < 15) {
                return 'rotate';
            }

            // Check delete button
            if (Math.abs(rx - halfW - 15) < 15 && Math.abs(ry + halfH + 15) < 15) {
                return 'delete';
            }

            // Check corner handles
            const corners = [
                { x: -halfW, y: -halfH, name: 'nw' },
                { x: halfW, y: -halfH, name: 'ne' },
                { x: -halfW, y: halfH, name: 'sw' },
                { x: halfW, y: halfH, name: 'se' }
            ];

            for (const corner of corners) {
                if (Math.abs(rx - corner.x) < 12 && Math.abs(ry - corner.y) < 12) {
                    return 'resize-' + corner.name;
                }
            }

            return 'move';
        }

        // Canvas click/touch handlers for layers
        canvas.addEventListener('mousedown', handleCanvasMouseDown);
        canvas.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });

        function handleCanvasMouseDown(e) {
            if (currentTool) return; // Drawing mode

            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            handleLayerInteraction(x, y, e);
        }

        function handleCanvasTouchStart(e) {
            if (currentTool) return;
            if (e.touches.length !== 1) return;

            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = (touch.clientX - rect.left) * (canvas.width / rect.width);
            const y = (touch.clientY - rect.top) * (canvas.height / rect.height);

            handleLayerInteraction(x, y, e);
        }

        function handleLayerInteraction(x, y, e) {
            // First check if clicking on selected layer's handles
            if (selectedLayer) {
                const handle = getHandleAtPoint(x, y, selectedLayer);

                if (handle === 'delete') {
                    layers = layers.filter(l => l !== selectedLayer);
                    selectedLayer = null;
                    renderLayers();
                    return;
                }

                if (handle === 'rotate') {
                    isRotatingLayer = true;
                    setupLayerDragListeners();
                    return;
                }

                if (handle && handle.startsWith('resize')) {
                    isResizingLayer = handle;
                    setupLayerDragListeners();
                    return;
                }
            }

            // Check if clicking on a layer
            const clickedLayer = getLayerAtPoint(x, y);

            if (clickedLayer) {
                selectedLayer = clickedLayer;
                isDraggingLayer = true;
                layerDragOffset = { x: x - clickedLayer.x, y: y - clickedLayer.y };
                setupLayerDragListeners();
                renderLayers();
            } else {
                // Clicked outside - deselect
                if (selectedLayer) {
                    selectedLayer = null;
                    renderLayers();
                }
            }
        }

        function setupLayerDragListeners() {
            document.addEventListener('mousemove', handleLayerDrag);
            document.addEventListener('mouseup', handleLayerDragEnd);
            document.addEventListener('touchmove', handleLayerTouchDrag, { passive: false });
            document.addEventListener('touchend', handleLayerDragEnd);
        }

        function handleLayerDrag(e) {
            if (!selectedLayer) return;

            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            updateLayerPosition(x, y);
        }

        function handleLayerTouchDrag(e) {
            if (!selectedLayer) return;
            if (e.touches.length !== 1) return;

            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = (touch.clientX - rect.left) * (canvas.width / rect.width);
            const y = (touch.clientY - rect.top) * (canvas.height / rect.height);

            updateLayerPosition(x, y);
        }

        function updateLayerPosition(x, y) {
            if (isDraggingLayer) {
                selectedLayer.x = x - layerDragOffset.x;
                selectedLayer.y = y - layerDragOffset.y;
            } else if (isRotatingLayer) {
                const dx = x - selectedLayer.x;
                const dy = y - selectedLayer.y;
                selectedLayer.rotation = Math.atan2(dx, -dy) * 180 / Math.PI;
            } else if (isResizingLayer) {
                const dx = Math.abs(x - selectedLayer.x);
                const dy = Math.abs(y - selectedLayer.y);
                const newSize = Math.max(30, Math.max(dx, dy) * 2);
                selectedLayer.width = newSize;
                selectedLayer.height = newSize;
                if (selectedLayer.type === 'sticker') {
                    selectedLayer.fontSize = newSize;
                }
            }

            renderLayers();
        }

        function handleLayerDragEnd() {
            if (isDraggingLayer || isRotatingLayer || isResizingLayer) {
                isDraggingLayer = false;
                isRotatingLayer = false;
                isResizingLayer = false;

                document.removeEventListener('mousemove', handleLayerDrag);
                document.removeEventListener('mouseup', handleLayerDragEnd);
                document.removeEventListener('touchmove', handleLayerTouchDrag);
                document.removeEventListener('touchend', handleLayerDragEnd);
            }
        }

        // Flatten layers to canvas
        function flattenLayers() {
            if (layers.length === 0) return;

            // Deselect so handles aren't rendered
            selectedLayer = null;
            renderLayers();

            // Update working image data to include flattened layers
            workingImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            layers = [];

            saveToHistory();
        }

        // Gradient Overlays
        function applyGradientOverlay(type) {
            if (!originalImage) return;

            const gradients = {
                sunset: [
                    { pos: 0, color: 'rgba(255, 107, 53, 0.4)' },
                    { pos: 0.5, color: 'rgba(247, 147, 30, 0.3)' },
                    { pos: 1, color: 'rgba(255, 204, 2, 0.2)' }
                ],
                vaporwave: [
                    { pos: 0, color: 'rgba(255, 113, 206, 0.35)' },
                    { pos: 0.5, color: 'rgba(1, 205, 254, 0.25)' },
                    { pos: 1, color: 'rgba(5, 255, 161, 0.2)' }
                ],
                neon: [
                    { pos: 0, color: 'rgba(255, 42, 109, 0.35)' },
                    { pos: 0.5, color: 'rgba(211, 0, 197, 0.3)' },
                    { pos: 1, color: 'rgba(5, 217, 232, 0.25)' }
                ],
                miami: [
                    { pos: 0, color: 'rgba(249, 83, 198, 0.4)' },
                    { pos: 1, color: 'rgba(185, 29, 115, 0.3)' }
                ],
                cyber: [
                    { pos: 0, color: 'rgba(0, 210, 255, 0.3)' },
                    { pos: 0.5, color: 'rgba(58, 123, 213, 0.25)' },
                    { pos: 1, color: 'rgba(106, 17, 203, 0.35)' }
                ],
                retro: [
                    { pos: 0, color: 'rgba(252, 70, 107, 0.35)' },
                    { pos: 1, color: 'rgba(63, 94, 251, 0.3)' }
                ]
            };

            const gradientDef = gradients[type];
            if (!gradientDef) return;

            // Create gradient based on type
            let gradient;
            if (type === 'sunset' || type === 'vaporwave') {
                // Top to bottom gradient
                gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            } else if (type === 'miami' || type === 'retro') {
                // Diagonal gradient
                gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            } else {
                // Radial gradient for neon and cyber
                gradient = ctx.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, 0,
                    canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) * 0.7
                );
            }

            gradientDef.forEach(stop => {
                gradient.addColorStop(stop.pos, stop.color);
            });

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            saveToHistory();
        }
    </script>
</body>

</html>